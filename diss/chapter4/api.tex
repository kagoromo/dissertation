\section{The LVish library API}\label{s:lvish-api}

\TODO{Edit this section.  It needs to cover effect levels, not just
  determinism levels.  Also, add examples from the lvar-examples
  repo.}

\TODO{Things I want to make sure and discuss here include ``why
  Haskell?''}

We have constructed a prototype implementation of LVish as a monadic library in
Haskell, which is available at 
\begin{center}
\url{http://hackage.haskell.org/package/lvish}
\end{center}
\ajt{Or would we rather link to github?}%
Our library adopts the basic approach
of the @Par@ monad~\cite{monad-par}, enabling us to employ our own notion of
lightweight, library-level threads with a custom scheduler.  It supports the
programming model laid out in Section~\ref{section:lvish-informal} in full,
including explicit handler pools.  It differs from our formal model in following
Haskell's by-need evaluation strategy, which also means that concurrency in the
library is \emph{explicitly marked}, either through uses of a @fork@ function or
through asynchronous callbacks, which run in their own lightweight thread.

Implementing LVish as a Haskell library makes it possible to provide
compile-time guarantees about determinism and quasi-determinism,
because programs written using our library run in our @Par@ monad and
can therefore only perform LVish-sanctioned side effects.
We take advantage of
this fact by indexing @Par@ computations with a phantom type
that indicates their \emph{determinism level}:
\begin{lstlisting}
  data Determinism = Det | QuasiDet
\end{lstlisting}
%% while the second is the standard phantom type used by the @ST@ monad, which is
%% used to ensure that LVars themselves cannot escape from uses of our @Par@ monad.
The @Par@ type constructor has the following kind:\footnote{We are here using
  the {\tt DataKinds} extension to Haskell to treat {\tt Determinism} as a
  kind.  In the full implementation, we include a second phantom type parameter to ensure that LVars
  cannot be used in multiple runs of the {\tt Par} monad, in a manner analogous to how the {\tt ST} monad prevents an {\tt STRef} from being returned from {\tt runST}.}
\begin{lstlisting}
  Par :: Determinism -> * -> *
\end{lstlisting}
together with the following suite of @run@ functions:
\begin{lstlisting}
  runPar   :: Par Det a -> a
  runParIO :: Par lvl a -> IO a
  runParThenFreeze :: DeepFrz a => Par Det a -> FrzType a
\end{lstlisting}
The public library API ensures that if code uses @freeze@, it is marked as
@QuasiDet@; thus, code that types as @Det@ is guaranteed to be fully
deterministic.  While LVish code with an arbitrary determinism level @lvl@ can be
executed in the @IO@ monad using @runParIO@, only @Det@ code can be executed as if it were pure,
since it is guaranteed to be free of visible side effects of nondeterminism.  In
the common case that @freeze@ is only needed at the end of an
otherwise-deterministic computation, @runParThenFreeze@ runs the computation to
completion, and then freezes the returned LVar, returning its exact value---and
is guaranteed to be deterministic.\footnote{The {\tt DeepFrz} typeclass is used
  to perform freezing of nested LVars, producing values of frozen type (as given
  by the {\tt FrzType} type function).}

%% The type @s@ (short for ``session'') that
%% appears in the @run@ functions also appears as a phantom type of LVars
%% themselves; the universal quantification forces each LVar to be tied to a single
%% session, \ie, a single use of a @run@ function~\cite{?}.  Readers unfamiliar with this
%% trick from the @ST@ monad can safely ignore the type parameter altogether.

\ajt{We don't actually prove that freeze-free code is deterministic, but it
  should follow pretty easily from the proof of quasi-determinism.  Perhaps we
  should claim it in the proof section?}
\lk{Well, to do this ``right'' we would have to not just prove that
  freeze-free code is deterministic, but we'd have to prove that
  freeze-happens-last code is deterministic...}

\subsection{The big picture}

We envision two parties interacting with the LVish library.  First,
there are data structure authors, who use the library directly to
implement a specific monotonic data structure (\eg, a monotonically
growing finite map).  Second, there are application writers, who are
clients of these data structures.  Only the application writers
receive a \mbox{(quasi-)determinism} guarantee; an author of a data
structure is responsible for ensuring that the states their data
structure can take on correspond to the elements of a lattice, and
that the exposed interface to it corresponds to some use of @put@,
@get@, @freeze@, and event handlers.

Thus, our library is focused primarily on \emph{lattice-generic}
infrastructure: the @Par@ monad itself, a thread scheduler, support
for blocking and signaling threads, handler pools, and event handlers.
Since this infrastructure is unsafe (does not guarantee
quasi-determinism), only data structure authors should import it,
subsequently exporting a \emph{limited} interface specific to their
data structure.  For finite maps, for instance, this interface might
include key/value insertion, lookup, event handlers and pools, and
freezing---along with higher-level abstractions built on top of these.

For this approach to scale well with available parallel resources, it
is essential that the data structures themselves support efficient
parallel access; a finite map that was simply protected by a global
lock would force all parallel threads to sequentialize their access.
Thus, we expect data structure authors to draw from the extensive
literature on scalable parallel data structures, employing techniques
like fine-grained locking and lock-free data structures~\cite{art}.
Data structures that fit into the LVish model have a special
advantage: because all updates must commute, it may be possible to
avoid the expensive synchronization which \emph{must} be used for
non-commutative operations~\cite{lawsOfOrder}.  And in any case,
monotonic data structures are usually much simpler to represent and
implement than general ones.
