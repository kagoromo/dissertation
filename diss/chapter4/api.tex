\section{The LVish library interface for application writers}\label{s:lvish-api}

In this section I illustrate the use of the LVish library from the
point of view of the application writer, through a series of
examples.\footnote{The examples in this section, among others, are
  available at \url{https://github.com/lkuper/lvar-examples/}.  All of
  the examples are tested against GHC 7.6.3, the most recent release
  at the time of this writing.\TODO{I should test against 7.8!}}

\subsection{Basic examples using IVars}

As mentioned in the previous section, the LVish library extends the
approach of Haskell's monad-par library for deterministic parallelism,
which allows communication between parallel tasks through IVars.
Recall that IVars can only be assigned to once.  Therefore the
following program written using @Par@ will deterministically raise an
error, because it tries to write to the IVar @num@ twice:

\singlespacing
\lstinputlisting{chapter4/code/ivar-example.hs}
\doublespacing

Here, @p@ is a computation of type @Par Int@, meaning that it runs in
the @Par@ monad (via the call to @runPar@) and returns a value of
@Int@ type.  @num@ is an IVar, created with a call to @new@ and then
assigned to via two calls to @put@, each of which runs in a separately
@fork@ed task.  The @runPar@ function is an implicit global barrier:
all @fork@s have to complete before @runPar@ can return.

The program raises a ``multiple put'' error at runtime, which is as it
should be: differing writes to the same shared location could cause
the subsequent call to @get@ to behave nondeterministically.  (Here,
@get@ has IVar semantics, not LVar semantics: rather than performing a
threshold read, it blocks until @num@ has been written, then unblocks
and evaluates to the exact contents of @num@.)

However, in monad-par, even multiple writes of the \emph{same} value
to an IVar will raise a ``multiple put'' error:

\singlespacing
\lstinputlisting{chapter4/code/repeated-4-ivar.hs}
\doublespacing

This program differs from the previous one only in that the two @put@s
are writing @4@ and @4@, rather than @3@ and @4@.  Even though the
call to @get@ would produce a deterministic result regardless of which
write happened first, the program still raises an error because of the
IVar single-write restriction.

Let us consider how a program that writes the same value to an IVar
twice would behave when written using the LVish library.  Of course,
in LVish we are not limited to IVars, but I will consider IVars first
as an interesting special case of LVars, and then go on to consider
some more sophisticated LVars later in this section.

A version of the above program written using LVish will write @4@ to
an IVar twice and then deterministically print @4@ instead of raising
an error:

\singlespacing
\lstinputlisting{chapter4/code/repeated-4-lvar.hs}
\doublespacing

Here, we import the @Control.LVish@ module rather than
@Control.Monad.Par@ (that is, we are using LVish instead of
monad-par), and we must specifically import @Data.LVar.IVar@ in order
to specify which LVar data structure we want to work with (since we
are no longer limited to IVars).  Just as in monad-par, the LVish
@runPar@ function is a global barrier: both @fork@s must compete
before @runPar@ can return.  Also, as before, we have @new@, @put@,
and @get@ operations that respectively create, update, and read from
@num@.  However, these operations now have LVar semantics: the @put@
operation performs a least-upper-bound write, and the @get@ operation
performs a threshold read, where the threshold set is implicitly the
set of all @Int@s.  We do not need to explicitly write down the
threshold set in the code; rather, it is the obligation of the
@Data.LVar.IVar@ module to provide operations (@put@ and @get@) that
have the semantic effect of least-upper-bound writes and threshold
reads (as I touched on earlier in
Section~\ref{subsection:lvars-the-model-versus-reality}).

There are two other important differences between the monad-par
program and the LVish program: the @Par@ type constructor has gained
two new type parameters, @e@ and @s@, and @p@'s type annotation now
has a \emph{type class constraint} of @(HasPut e, HasGet e)@.
Furthermore, we have added two @LANGUAGE@ pragmas, instructing the
compiler that we are now using the @DataKinds@ and @TypeFamilies@
language extensions.  In the following section, I explain these
changes.

\subsection{The \il{e} and \il{s} type parameters: effect tracking and session tracking}

In order to support both determinism and quasi-determinism guarantees
in the LVish library, we need to be able to guarantee that only
certain LVar effects can occur within a given @Par@ computation.  In a
deterministic computation, only update operations (such as @put@) and
threshold reads should be allowed; in a quasi-deterministic
computation, @freeze@ operations should be allowed as well.  Yet other
combinations may be desirable: for instance, we may want a computation
to perform \emph{only} writes, and not reads.  Furthermore, we want to
be able to specifically allow or disallow \emph{non-idempotent} update
operations, which I discuss in more detail in
Section~\ref{subsection:lvish-discussion-leveraging-idempotency}.

In order to capture these constraints and make them explicit in the
types of LVar computations, LVish indexes @Par@ computations with a
\emph{phantom type} @e@ that indicates their \emph{effect level}.  The
@Par@ type becomes, instead, @Par e@, where @e@ is a type-level
encoding of booleans indicating which operations, such as writes,
reads, or freeze operations, are allowed to occur inside it.

Since we do not know in advance which effects this
``switch-on-and-off'' capability will need to support, LVish follows
the precedent of Kiselyov \etal~on extensible effects in
Haskell~\cite{oleg-amr-haskell-2013}: it abstracts away the specific
structure of @e@ into \emph{type class constraints}, which allow a
@Par@ computation to be annotated with the \emph{interface} that its
@e@ type parameter is expected to satisfy.  This static effect
tracking mechanism allows us to define ``effect shorthands'' and use
them as Haskell type class constraints.  For example, a @Par@
computation annotated with the effect level constraint @HasPut@ can
perform @put@s.  In our example above, @p@ is annotated with both
@HasPut@ and @HasGet@ and therefore can perform both @put@s and
@get@s.  We will see several more examples of effect level constraints
in LVish @Par@ computations shortly.  The effect tracking
infrastructure is also the reason why we need to use the @DataKinds@
and @TypeFamilies@ language extensions in our LVish programs.  For
brevity, I will elide the @LANGUAGE@ pragmas in the rest of the
example LVish programs in this section.  \TODO{I need to figure out
  and actually explain \emph{why} the effect tracking requires
  \il{DataKinds} and \il{TypeFamilies}.}

The LVish @Par@ type constructor also has a second type parameter,
@s@, making @Par e s a@ the complete type of a @Par@ computation that
returns a result of type @a@.  The @s@ parameter ensures that, when a
computation in the Par monad is run using the provided @runPar@
operation (or using a variant of @runPar@, which I will discuss
below), it is not possible to return an LVar from @runPar@ and reuse
it in another call to @runPar@.  The @s@ type parameter also appears
in the types of LVars themselves, and the universal quantification of
@s@ in @runPar@ and its variants forces each LVar to be tied to a
single ``session'', \ie, a single use of a @run@ function, in the same
way that the @ST@ monad in Haskell prevents an @STRef@ from escaping
@runST@.  Doing so allows the Lvish implementation to assume that
LVars are created and used within the same session.\footnote{The
  addition of the \il{s} type parameter to \il{Par} in the LVish
  library has nothing to do with LVars in particular; it would also be
  a useful addition to the original \il{Par} library to prevent
  programmers from reusing an IVar from one \il{Par} computation to
  another, which is, as Simon Marlow has noted, ``a Very Bad Idea;
  don't do it''~\cite{marlow-book}.}

\subsection{Non-idempotent writes: an increment-only counter}

\TODO{I want to put an example here, but the last time I tried
  actually using \il{Data.LVar.Counter} in LVish, it didn't work. :(
  Need to figure this out!}

\subsection{Container LVars: a shopping cart example}

Next, let us consider an example program in which we concurrently add
items to a shopping cart.  Here, the cart is represented using the
@PureMap@ LVar type (provided by the @Data.LVar.PureMap@ module),
which is a key-value map where the keys are items in the cart and the
values are the quantities of each item.\footnote{The ``pure'' in
  \il{PureMap} distinguishes it from LVish's other map data structure,
  \il{SLMap}, which is a lock-free data structure based on concurrent
  skip lists.  \il{PureMap}, on the other hand, is a reference
  implementation of a map, which uses a pure \il{Data.Map} wrapped in
  a mutable container.  Both data structures present the same API, but
  \il{SLMap} is designed to scale as parallel resources are added.  I
  discuss the role of lock-free data structures in LVish in more
  detail in Section~\ref{subsection:lvish-parallel-speedup-results}.
  In any case, either \il{PureMap} or \il{SLMap} would have worked for
  this example.}

\singlespacing
\lstinputlisting{chapter4/code/map-lvar-getkey-lib.hs}
\doublespacing

Here, the @newEmptyMap@ operation creates a new @PureMap@,
and the @insert@ operation allows us to add new key-value pairs to the
cart.  In this case, we are adding the @Book@ item with a quantity of
@2@, and the @Shoes@ item with a quantity of @1@.

The @getKey@ operation allows us to threshold on a key, in this case
@Book@, and get back the value associated with that key.  The
\emph{implicit} threshold set of a call to @getKey@ is the set of all
values that might be associated with a key; in this case, the set of
all @Int@s.  This is a valid threshold set because in this example,
map entries are \emph{immutable}: we cannot, for instance, insert a
key of @Book@ with a quantity of @2@ and then later change the @2@ to
@3@.  In a more realistic shopping cart, the values in the cart could
themselves be LVars representing incrementable counters, as in the
previous section.  \TODO{I'd like there to be some kind of footnote
  here about the problem that LVars-that-contain-LVars presents for
  determinism.  I don't actually understand the problem, though.}
However, a shopping cart from which we can \emph{delete} items is not
possible because it would go against the principle of monotonic
growth.\footnote{Having said that, one way to encode a container that
  allows both insertion and removal of elements is to represent it
  internally with \emph{two} containers, one for the inserted elements
  and one for the removed elements, where both containers grow
  monotonically.  \emph{Conflict-free replicated data types}
  (CRDTs)~\cite{crdts} use variations on this approach to encode
  counters that support decrements as well as increments, sets that
  support removals as well as additions, and other data structures
  that support seemingly non-monotonic operations.  I discuss the
  relationship of LVars to CRDTs in more detail in
  Chapter~\ref{ch:distributed}.}

\subsection{A quasi-deterministic shopping cart example}

So far, the examples that we have seen are fully deterministic; they
do not use @freeze@.  Next, let us consider a program where we freeze
and read the contents of a shopping cart concurrently with inserting
into it.

\TODO{finish this}

\singlespacing
\lstinputlisting{chapter4/code/map-lvar-quasi.hs}
\doublespacing

\subsection{Regaining determinism with \il{runParThenFreeze}}

\TODO{finish this}

\singlespacing
\lstinputlisting{chapter4/code/map-lvar-freezeafter.hs}
\doublespacing

\subsection{Event-driven programming: a deterministic parallel graph traversal}

Finally, let us look at some examples that use event handlers as well
as freezing.

Here, @neighbors@ is an operation that takes a @Graph@ and a @Vertex@
and returns a list of the vertex's neighbor vertices.

Furthermore, @newHandler@ is an operation that takes an LVar and a
callback @f@ and creates and returns a handler pool to which a single
event handler has been added: one that associates the provided LVar
with the provided callback.  We can implement @newHandler@ using
LVish's built-in @newPool@ and @addHandler@ operations, as follows:

\singlespacing
\begin{lstlisting}
newHandler lv f = do
  hp <- newPool
  addHandler (Just hp) lv f
  return hp
\end{lstlisting}
\doublespacing

\singlespacing
\lstinputlisting{chapter4/code/graph-traversal-explicit-freeze.hs}
\doublespacing

\singlespacing
\lstinputlisting{chapter4/code/graph-traversal-implicit-freeze.hs}
\doublespacing

\TODO{finish this}
