\section{The LVish library interface}\label{s:lvish-api}

In this section I explain the LVish library API. \TODO{More
  explanatory text here.}

\subsection{The \lstinline|s| and \lstinline|e| type parameters}

In order to support both determinism and quasi-determinism guarantees
in the LVish library, we need to be able to guarantee that only
certain LVar effects can occur within a given @Par@ computation.  In a
deterministic computation, only @put@ and @get@ should be allowed; in
a quasi-deterministic computation, @freeze@ operations should be
allowed as well.  Yet other combinations may be desirable: for
instance, we may want a computation to perform \emph{only} writes, and
not reads.  Furthermore, we might want to specifically allow or
disallow \emph{non-idempotent} writes, as discussed in
Section~\ref{s:lvars-generalizing}.

In order to capture these constraints and make them explicit in the
types of LVar computations, we index @Par@ computations with a
\emph{phantom type} @e@ that indicates their \emph{effect level}.  The
@Par@ type becomes, instead, @Par e@, where @e@ is a type-level
encoding of booleans indicating which operations, such as writes,
reads, or freeze operations, are allowed to occur inside it.

Since we do not know in advance which effects this
``switch-on-and-off'' capability will need to support, we follow the
precedent of Kiselyov \etal~on extensible effects in
Haskell~\cite{oleg-amr-haskell-2013}: we abstract away the specific
structure of @e@ into \emph{type class constraints}, which allow a
@Par@ computation to be annotated with the \emph{interface} that its
@e@ type parameter is expected to satisfy.  This static effect
tracking mechanism allows us to define ``effect shorthands'' and use
them as Haskell type class constraints.  For example, a @Par@
computation annotated with the effect level constraint @HasPut@ can
perform @put@s.  We will see several examples of effect level
constraints in @Par@ computations shortly.

Our @Par@ type constructor also has a second type parameter, @s@,
making @Par e s a@ the complete type of a @Par@ computation that
returns a result of type @a@.  The @s@ parameter ensures that, when a
computation in the Par monad is run using the provided @runPar@
operation (or using a variant of @runPar@, which I will discuss
below), it is not possible to return an LVar from @runPar@ and reuse
it in another call to @runPar@.  The @s@ type parameter also appears
in the types of LVars themselves, and the universal quantification of
@s@ in @runPar@ and its variants forces each LVar to be tied to a
single ``session'', \ie, a single use of a @run@ function, in the same
way that the @ST@ monad in Haskell prevents an @STRef@ from escaping
@runST@.  Doing so allows the Lvish implementation to assume that
LVars are created and used within the same session.\footnote{The
  addition of the \lstinline|s| type parameter to \lstinline|Par| in
  the LVish library does not have to do with LVars as such. In the
  monad-par library there is no \lstinline|s| parameter on
  \lstinline|Par| computations and therefore nothing to prevent a
  programmer from reusing an IVar from one \lstinline|Par| computation
  to another.  As Simon Marlow notes in \emph{Parallel and Concurrent
    Programming in Haskell}~\cite{marlow-book}, ``This is a Very Bad
  Idea; don't do it.''}

\lk{I feel like this section would be easier to understand if I
  included the types of \lstinline|runPar| and friends, but they're so
  ugly with the effect switchboards that I don't want to put them in
  here. :(}

