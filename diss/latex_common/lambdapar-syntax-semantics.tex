% Grammar for lambdapar.
\newcommand{\FigLambdaparGrammar}{
\begin{figure}
  Given a lattice $(D, \myleq)$ with elements $d \in D$, least element $\bot$, and greatest element $\top$:
    \[
    \begin{array}{rlcl}
      \mbox{configurations} &\conf & \bnfdef & \config{S}{e} \sep \error \\
      \mbox{expressions} & e & \bnfdef & 
           x \sep v \sep \app{e}{e} \sep \NEW \sep 
           \putexp{e}{e} \sep \\
           & & &
           \getexp{e}{e} \sep \reifyexp{e} \\
      \mbox{values} & v & \bnfdef & l \sep Q \sep \lam{x}{e} \\
      \mbox{threshold set literals} & Q & \bnfdef & 
           \stateset{d_1,d_2, \ldots } \\
      \mbox{stores} & S & \bnfdef &  \top_S \sep \store{\storebinding{l_1}{d_1}, \dots, \storebinding{l_n}{d_n}} \\
           & & &
           \mbox{(where $d_i \neq \top$)} \\
    \end{array}
    \]
  \caption{\footnotesize Syntax for $\lambdapar$.}
  \label{f:lambdapar-grammar}
\end{figure}
}

% An idealized lambdapar semantics, with reflexive rules.
\newcommand{\FigLambdaparRefl}{
\begin{figure*}[]
  Given a lattice $(D, \myleq)$ with elements $d \in D$, least element $\bot$, and greatest element $\top$:

\vspace{.4em}
\scriptsize
$\incomp{Q} \defeq \qforall{a,b \in Q}{(a \neq b \implies \lub{a}{b}
  = \top)}$\hfill\fbox{$\config{S}{e} \parstepsto \config{S'}{e'}$}

\vspace{.4em} \hfill{(where $\config{S'}{e'} \neq \error$)}

  \begin{mathpar}
    \inferrule*[lab=E-Refl]
        {~}
        {\config{S}{e} \parstepsto \config{S}{e}}

    \inferrule*[lab=E-ParApp]
        {\config{S}{e_1} \parstepsto \config{S_1}{e_1'} \\ 
          \config{S}{e_2} \parstepsto \config{S_2}{e_2'} \\
          \config{S_1^{r}}{e_1'^{r}} = \renamelocs{\config{S_1}{e_1'}}{S_2}{S} \\
          \lubstore{S_1^{r}}{S_2} \neq \topS }
        {\config{S}{\app{e_1}{e_2}} \parstepsto \config{\lubstore{S_1^{r}}{S_2}}{\app{e_1'^{r}}{e_2'}}}

    \inferrule*[lab=E-Put-1]
        {\config{S}{e_1} \parstepsto \config{S_1}{e_1'}}
        {\config{S}{\putexp{e_1}{e_2}} \parstepsto \config{S_1}{\putexp{e_1'}{e_2}}}

    \inferrule*[lab=E-Put-2]
        {\config{S}{e_2} \parstepsto \config{S_2}{e_2'}}
        {\config{S}{\putexp{e_1}{e_2}} \parstepsto \config{S_2}{\putexp{e_1}{e_2'}}}

    \inferrule*[lab=E-PutVal]
        {S(l) = d_2 \\ d_1 \in D \\ \lub{d_1}{d_2} \neq \top}
        %      {\config{S}{\putexp{l}{\stateset{d_2}}} \parstepsto \config{\extS{S}{l}{LUB(d_1,d_2)}}{\emptyset}}
        {\config{S}{\putexp{l}{\stateset{d_1}}} \parstepsto
          \config{\extS{S}{l}{\lub{d_1}{d_2}}}{\stateset{}}}

    \inferrule*[lab=E-Get-1]
        {\config{S}{e_1} \parstepsto \config{S_1}{e_1'}}
        {\config{S}{\getexp{e_1}{e_2}} \parstepsto \config{S_1}{\getexp{e_1'}{e_2}}}

    \inferrule*[lab=E-Get-2]
        {\config{S}{e_2} \parstepsto \config{S_2}{e_2'}}
        {\config{S}{\getexp{e_1}{e_2}} \parstepsto \config{S_2}{\getexp{e_1}{e_2'}}}

    \hspace{-1em}\inferrule*[lab=E-GetVal]
        {S(l) = d_2 \\ \incomp{Q} \\ Q \subseteq D \\ d_1 \in Q \\ d_1 \myleq d_2}
        {\config{S}{\getexp{l}{Q}} \parstepsto \config{S}{\stateset{d_1}}}

    \hspace{-1em}\inferrule*[lab=E-Convert]
        {\config{S}{e} \parstepsto \config{S'}{e'}}
        {\config{S}{\reifyexp{e}} \parstepsto \config{S'}{\reifyexp{e'}}}

    \hspace{-2em}\inferrule*[lab=E-ConvertVal]
        {~} 
        {\config{S}{\reifyexp{v}} \parstepsto \config{S}{\delta(v)}}

    \hspace{-2em}\inferrule*[lab=E-Beta]
        {~}
        {\config{S}{\app{(\lam{x}{e})}{v}} \parstepsto \config{S}{\subst{e}{x}{v}}}

    \hspace{-2em}\inferrule*[lab=E-New, right=\textnormal{($l \notin \dom{S}$)}]
        {~}
        {\config{S}{\NEW} \parstepsto \config{\extS{S}{l}{\bot}}{l}}
  \end{mathpar}
  \hrule
  \vspace{1em}
  \hfill \fbox{$\config{S}{e} \parstepsto \error$}
  \begin{mathpar}
    \inferrule*[lab=E-ReflErr]
        {~}
        {\error \parstepsto \error}

    \inferrule*[lab=E-ParAppErr]
        {\config{S}{e_1} \parstepsto \config{S_1}{e_1'} \\ 
          \config{S}{e_2} \parstepsto \config{S_2}{e_2'} \\
          \config{S_1^{r}}{e_1'^{r}} = \renamelocs{\config{S_1}{e_1'}}{S_2}{S} \\
          \lubstore{S_1^{r}}{S_2} = \topS }
        {\config{S}{\app{e_1}{e_2}} \parstepsto \error}

    \inferrule*[lab=E-AppErr-1]
        {\config{S}{e_1} \parstepsto \error}
        {\config{S}{\app{e_1}{e_2}} \parstepsto \error}

    \inferrule*[lab=E-AppErr-2]
        {\config{S}{e_2} \parstepsto \error}
        {\config{S}{\app{e_1}{e_2}} \parstepsto \error}

    \inferrule*[lab=E-PutErr-1]
        {\config{S}{e_1} \parstepsto \error}
        {\config{S}{\putexp{e_1}{e_2}} \parstepsto \error}

    \inferrule*[lab=E-PutErr-2]
        {\config{S}{e_2} \parstepsto \error}
        {\config{S}{\putexp{e_1}{e_2}} \parstepsto \error}

    \inferrule*[lab=E-PutValErr]
        {S(l) = d_2 \\ d_1 \in D \\ \lub{d_1}{d_2} = \top}
        {\config{S}{\putexp{l}{\stateset{d_1}}} \parstepsto 
           \error}

    \inferrule*[lab=E-GetErr-1]
        {\config{S}{e_1} \parstepsto \error}
        {\config{S}{\getexp{e_1}{e_2}} \parstepsto \error}

    \inferrule*[lab=E-GetErr-2]
        {\config{S}{e_2} \parstepsto \error}
        {\config{S}{\getexp{e_1}{e_2}} \parstepsto \error}

    \inferrule*[lab=E-ConvertErr]
        {\config{S}{e} \parstepsto \error}
        {\config{S}{\reifyexp{e}} \parstepsto \error}

  \end{mathpar}
  \caption{\footnotesize An operational semantics for $\lambdapar$.}
  \label{f:lambdapar-refl}

\end{figure*}
}

% A lambdapar semantics without reflexive rules: easier to implement.
\newcommand{\FigLambdapar}{
\begin{figure}
  \begin{mathpar}
    \scriptsize
    \inferrule*[lab=E-App-1]
        {\config{S}{e_1} \parstepsto \config{S_1}{e_1'}}
        {\config{S}{\app{e_1}{e_2}} \parstepsto \config{S_1}{\app{e_1'}{e_2}}}

    \inferrule*[lab=E-App-2]
        {\config{S}{e_2} \parstepsto \config{S_2}{e_2'}}
        {\config{S}{\app{e_1}{e_2}} \parstepsto \config{S_2}{\app{e_1}{e_2'}}}

  \end{mathpar}
  \caption{An alternate operational semantics for $\lambdapar$: remove
    the reflexive reduction rules {\sc E-Refl} and {\sc E-ReflErr}
    from the semantics of Figure~\ref{f:lambdapar-refl}, and add the
    two rules shown here.}
  \label{f:lambdapar}

\end{figure}
}

% The ``value'' tweak to the lambdapar semantics.
\newcommand{\FigLambdaparGetValBlock}{
\begin{figure}
  \begin{mathpar}
    \scriptsize
    \inferrule*[lab=E-App-1]
        {\config{S}{e_1} \parstepsto \config{S_1}{e_1'}}
        {\config{S}{\app{e_1}{v}} \parstepsto \config{S_1}{\app{e_1'}{v}}}

    \inferrule*[lab=E-App-2]
        {\config{S}{e_2} \parstepsto \config{S_2}{e_2'}}
        {\config{S}{\app{v}{e_2}} \parstepsto \config{S_2}{\app{v}{e_2'}}}

    \inferrule*[lab=E-GetValBlock]
        {S(l) = d_2  \hspace{2em} \incomp{Q} \hspace{2em} Q \subseteq D \hspace{2em} Q \neq \emptyset \hspace{2em} \qforall{d_1 \in Q}{d_1 \not\myleq d_2}}
        {\config{S}{\getexp{l}{Q}} \parstepsto \config{S}{\getexp{l}{Q}}}
  \end{mathpar}
  \caption{A further tweak to the operational semantics of
    Figure~\ref{f:lambdapar}.}
  \label{f:lambdapar-getvalblock}
\end{figure}
}

