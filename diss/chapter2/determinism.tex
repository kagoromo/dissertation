\section{Proof of determinism for
  $\lambdaLVar$}\label{s:lvars-proof}

The main technical result of this chapter is a proof of determinism
for the $\lambdaLVar$ language.  The determinism theorem says that if
two executions starting from a given configuration $\conf$ terminate
in configurations $\conf'$ and $\conf''$, then $\conf'$ and $\conf''$
are the same configuration, up to a permutation on locations.  (I
discuss permutations in more detail below, in
Section~\ref{subsection:lvars-permutations}.)

In order to prove determinism for $\lambdaLVar$, I first prove several
supporting lemmas.  The structure of the proof is similar to that of
the proof of determinism for Featherweight CnC given by Budimli\'c
\etal~\cite{CnC}.  I reuse the naming conventions of Budimli\'c
\etal~for Lemmas~\ref{lem:lvars-monotonicity}
through~\ref{lem:lvars-strong-local-confluence}, although the
statements and proofs of those lemmas differ considerably in the
setting of $\lambdaLVar$, due to the generality of LVars.

However, Lemmas~\ref{lem:lvars-strong-one-sided-confluence}
through~\ref{lem:lvars-confluence} are nearly identical to the
corresponding lemmas in the Featherweight CnC determinism proof.  This
is the case because, once Lemmas~\ref{lem:lvars-monotonicity} through
\ref{lem:lvars-strong-local-confluence} are established, the remainder
of the determinism proof does not need to deal specifically with the
semantics of LVars, lattices, or the store, and instead deals only
with execution steps at a high level.

\TODO{Say something about how later I'll show determinism for
  generalized monotonic writes and generalized threshold reads, if in
  fact I'm going to do that.}

\subsection{Permutations and permutability}\label{subsection:lvars-permutations}

\TODO{This text is very similar to what's in Neel's Simple FRP
  paper---revise it!}

Before getting into the interesting part of the determinism proof, we
need to deal with a technical issue.  The {\sc E-New} rule in the
reduction semantics is non-deterministic; it allocates a fresh
location $l \in \Loc$, with the only requirement on $l$ being that it
is not yet in the domain of the store.  Therefore, multiple runs of
the same program may differ in which locations they allocate.
Intuitively, this is not a serious problem, since our allocator could
always have chosen a different location to have allocated.  To
formalize this intuition, I introduce the idea of \emph{permutations}
and of the permutability of a transition.

Recall from Section~\ref{subsection:lvars-stores} that we have a
countable set of locations $\Loc$.  Then, a \emph{permutation} is
defined as follows:

\LVarsDefPermutation

Condition (1) in Definition~\ref{def:lvars-permutation} ensures that
we only consider location renamings that we can undo, and condition
(2) ensures that we only consider renamings of a finite number of
locations.

We can straightforwardly lift Definition~\ref{def:lvars-permutation}
to expressions and stores, and hence also to configurations.  To lift
a permutation $\pi$ to expressions, we over the syntax of terms
structurally and apply $\pi$ to any locations that occur in the term.
To lift $\pi$ to stores, we apply $\pi$ to all locations in the domain
of the store.  (We do not have to do any renaming in the codomain of
the store, since locations cannot occur in elements of the
application-specific lattice $D$.)

\LVarsDefPermutationExpression

\LVarsDefPermutationStore

\LVarsDefPermutationConfiguration

With these definitions in place, I can show that transitions are
permutable:

\LVarsLemPermutability
\begin{proof}
  See Section~\ref{section:lvars-permutability-proof}.
\end{proof}

\subsection{Monotonicity lemma}

\TODO{Figure out where this comes in, and how it needs to change.}

The Monotonicity lemma says that, as evaluation proceeds according to
the $\parstepsto$ relation, the store can only grow with respect to
the $\leqstore{}{}$ ordering.

\LVarsLemMonotonicity
\begin{proof}
  By induction on the derivation of $\config{S}{e} \parstepsto
  \config{S'}{e'}$, by cases on the last rule in the derivation; see
  Section~\ref{section:lvars-monotonicity-proof}.
\end{proof}

\subsection{Independence lemma}\label{subsection:lvars-independence}

\TODO{Figure out where this comes in, and how it needs to change.}

The Independence lemma establishes a ``frame property'' for
$\lambdaLVar$ that captures the idea that independent effects commute
with each other.  Consider an expression $e$ that runs starting in
store $S$ and steps to $e'$, updating the store to $S'$.  The
Independence lemma provides a double-edged guarantee about what will
happen if we evaluate $e$ starting from a larger store
$\lubstore{S}{S''}$: first, $e$ will update the store to
$\lubstore{S'}{S''}$; second, $e$ will step to $e'$ as it did before.
Here $\lubstore{S}{S''}$ is the least upper bound of the original $S$
and some other store $S''$ that is ``framed on'' to $S$; intuitively,
$S''$ is the store resulting from some other independently-running
computation.

Lemma~\ref{lem:lvars-independence} requires as a precondition that the
store $S''$ must be \emph{non-conflicting} with the original
transition from $\config{S}{e}$ to $\config{S'}{e'}$, meaning that
locations in $S''$ cannot share names with locations newly allocated
during the transition; this rules out location name conflicts caused
by allocation.

\LVarsDefNonConflicting

\LVarsLemIndependence
\begin{proof}
  By induction on the derivation of $\config{S}{e} \parstepsto
  \config{S'}{e'}$, by cases on the last rule in the derivation; see
  Section~\ref{section:lvars-independence-proof}.
\end{proof}

\subsection{Clash lemma}

The Clash lemma, Lemma~\ref{lem:lvars-clash}, is similar to the
Independence lemma, but handles the case where $\lubstore{S'}{S''} =
\topS$.  It establishes that, in that case,
$\config{\lubstore{S}{S''}}{e}$ steps to $\error$.

\lk{We didn't need the Clash lemma for the quasi-determinism proof,
  but I'm pretty sure the only reason we didn't need it was because
  quasi-determinism is ``...or $\error$''.  I think we actually do
  need it here.}

\LVarsLemClash
\begin{proof}
  By induction on the derivation of $\config{S}{e} \parstepsto
  \config{S'}{e'}$, by cases on the last rule in the derivation; see
  Section~\ref{section:lvars-clash-proof}.
\end{proof}

\subsection{Error Preservation lemma}

Lemma~\ref{lem:lvars-error-preservation}, Error Preservation, says
that if a configuration $\config{S}{e}$ steps to $\error$, then
evaluating $e$ in the context of some larger store will also result in
$\error$.

\lk{We didn't need the Error Preservation lemma for the
  quasi-determinism proof, but I'm pretty sure the only reason we
  didn't need it was because quasi-determinism is ``...or $\error$''.
  I think we actually do need it here.}

\LVarsLemErrorPreservation
\begin{proof}
  By induction on the derivation of $\config{S}{e} \parstepsto
  \error$, by cases on the last rule in the derivation; see
  Section~\ref{section:lvars-error-preservation-proof}.
\end{proof}

\subsection{Confluence lemmas}\label{subsection:lvars-confluence}

Lemma~\ref{lem:lvars-strong-local-confluence}, the Strong Local
Confluence lemma, says that if a configuration $\conf$ can step to
configurations $\conf_a$ and $\conf_b$, then there exists an
configuration $\conf_c$ that $\conf_a$ and $\conf_b$ can each reach in
at most one step.  Lemmas~\ref{lem:lvars-strong-one-sided-confluence}
and~\ref{lem:lvars-strong-confluence} then generalize that result to
arbitrary numbers of steps.

The structure of this part of the proof differs slightly from the
Budimli\'c \etal~determinism proof for Featherweight CnC.  Budimli\'c
\etal~prove a \emph{diamond} property, in which $\conf_a$ and
$\conf_b$ each step to $\conf_c$ in \emph{exactly} one step.  They
then get a property like Lemma~\ref{lem:lvars-strong-local-confluence}
as an immediate consequence of the diamond property, by choosing $i =
j = 1$.  But a true diamond property with exactly one step ``on each
side of the diamond'' is stronger than we need here, and, in fact,
does not hold for $\lambdaLVar$; so, instead, I prove the weaker ``at
most one step'' property directly as
Lemma~\ref{lem:lvars-strong-local-confluence}.

\LVarsLemStrongLocalConfluence
\begin{proof}
  By induction on the derivation of $\conf \parstepsto \conf_a$, by
  cases on the last rule in the derivation; see
  Section~\ref{section:lvars-strong-local-confluence-proof}.
\end{proof}

\LVarsLemStrongOneSidedConfluence
\begin{proof}
  By induction on $m$; see
  Section~\ref{section:lvars-strong-one-sided-confluence-proof}.
\end{proof}

\LVarsLemStrongConfluence
\begin{proof}
  By induction on $n$; see
  Section~\ref{section:lvars-strong-confluence-proof}.
\end{proof}

\LVarsLemConfluence

\subsection{Determinism theorem}

Finally, the determinism theorem, Theorem~\ref{thm:lvars-determinism},
is a direct result of Lemma~\ref{lem:lvars-confluence}:

\LVarsThmDeterminism

\subsection{Discussion: termination}

I have followed Budimli\'c \etal~\cite{CnC} in treating
\emph{determinism} separately from the issue of \emph{termination}.
Yet one might legitimately be concerned that in $\lambdaLVar$, a
configuration could have both an infinite reduction path and one that
terminates with a value.  Theorem~\ref{thm:lvars-determinism} says
that if two runs of a given $\lambdaLVar$ program reach configurations
where no more reductions are possible, then they have reached the same
configuration.  Hence Theorem~\ref{thm:lvars-determinism} handles the
case of \emph{deadlocks} already: a $\lambdaLVar$ program can deadlock
(\eg, with a blocked $\GET$), but it will do so deterministically.

However, Theorem~\ref{thm:lvars-determinism} has nothing to say about
\emph{livelocks}, in which a program reduces infinitely.  It would be
desirable to have a \emph{consistent termination} property which would
guarantee that if one run of a given $\lambdaLVar$ program terminates
with a non-$\error$ result, then every run will.  I conjecture (but do
not prove) that such a consistent termination property holds for
$\lambdaLVar$.  Such a property could be paired with
Theorem~\ref{thm:lvars-determinism} to guarantee that if one run of a
given $\lambdaLVar$ program terminates in a non-$\error$ configuration
$\sigma$, then every run of that program terminates in $\sigma$.  (The
``non-$\error$ configuration'' condition is necessary because it is
possible to construct a $\lambdaLVar$ program that can terminate in
$\error$ on some runs and diverge on others.  By contrast, the
existing determinism theorem does not have to treat $\error$
specially.)
