\section{Proof of determinism for
  $\lambdaLVar$}\label{s:lvars-proof}

The main technical result of this chapter is a proof of determinism
for the $\lambdaLVar$ language.  The determinism theorem says that if
two executions starting from a given configuration $\conf$ terminate
in configurations $\conf'$ and $\conf''$, then $\conf'$ and $\conf''$
are the same configuration, up to a permutation on locations.

In order to prove determinism for $\lambdaLVar$, I first prove several
supporting lemmas.  The structure of the proof is similar to that of
the proof of determinism for Featherweight CnC given by Budimli\'c
\etal~\cite{CnC}.  I reuse the naming conventions of Budimli\'c
\etal~for Lemmas~\ref{lem:lvars-monotonicity} through
\ref{lem:lvars-diamond}, although the statements and proofs of those
lemmas differ considerably in the setting of $\lambdaLVar$, due to the
generality of LVars.

However, Lemmas~\ref{lem:lvars-strong-one-sided-confluence},
\ref{lem:lvars-strong-confluence}, and \ref{lem:lvars-confluence} are
nearly identical to the corresponding lemmas in the Featherweight CnC
determinism proof.  This is the case because, once
Lemmas~\ref{lem:lvars-monotonicity} through \ref{lem:lvars-diamond}
are established, the remainder of the determinism proof does not need
to deal specifically with the semantics of LVars. \TODO{Something like
  this is true, but audit this paragraph to make sure after the proof
  is done.}

\TODO{Say something about how later I'll show determinism for
  generalized monotonic writes and generalized threshold reads, if in
  fact I'm going to do that.}

\subsection{Monotonicity lemma}

The Monotonicity lemma says that, as evaluation proceeds according to
the $\parstepsto$ relation, the store can only grow with respect to
the $\leqstore{}{}$ ordering.

\LVarsLemMonotonicity
\input{chapter2/determinism-monotonicity-proof}

\subsection{Independence lemma}\label{subsection:lvars-independence}

In order to show
Lemma~\ref{lem:lvars-strong-local-confluence}\TODO{audit}, I first
establish a ``frame property'' for $\lambdaLVar$ that captures the
idea that independent effects commute with each other.
Lemma~\ref{lem:lvars-independence}, the Independence lemma, is this
frame property.  Consider an expression $e$ that runs starting in
store $S$ and steps to $e'$, updating the store to $S'$.  The
Independence lemma provides a double-edged guarantee about what will
happen if we evaluate $e$ starting from a larger store
$\lubstore{S}{S''}$: first, $e$ will update the store to
$\lubstore{S'}{S''}$; second, $e$ will step to $e'$ as it did before.
Here $\lubstore{S}{S''}$ is the least upper bound of the original $S$
and some other store $S''$ that is ``framed on'' to $S$; intuitively,
$S''$ is the store resulting from some other independently-running
computation.

Lemma~\ref{lem:lvars-independence} requires as a precondition that the
store $S''$ must be \emph{non-conflicting} with the original
transition from $\config{S}{e}$ to $\config{S'}{e'}$, meaning that
locations in $S''$ cannot share names with locations newly allocated
during the transition; this rules out location name conflicts caused
by allocation.

\LVarsDefNonConflicting

\LVarsLemIndependence
\input{chapter2/determinism-independence-proof}

\subsection{Clash lemma}

The Clash lemma, Lemma~\ref{lem:lvars-clash}, is similar to the
Independence lemma, but handles the case where $\lubstore{S'}{S''} =
\topS$.  It establishes that, in that case,
$\config{\lubstore{S}{S''}}{e}$ steps to $\error$.

\lk{We didn't need the Clash lemma for the quasi-determinism proof,
  but I'm pretty sure the only reason we didn't need it was because
  quasi-determinism is ``...or $\error$''.  I think we actually do
  need it here.}

\LVarsLemClash
\input{chapter2/determinism-clash-proof}

\subsection{Error Preservation lemma}

Lemma~\ref{lem:lvars-error-preservation}, Error Preservation, says
that if a configuration $\config{S}{e}$ steps to $\error$, then
evaluating $e$ in the context of some larger store will also result in
$\error$.

\lk{We didn't need the Error Preservation lemma for the
  quasi-determinism proof, but I'm pretty sure the only reason we
  didn't need it was because quasi-determinism is ``...or $\error$''.
  I think we actually do need it here.}

\LVarsLemErrorPreservation
\input{chapter2/determinism-error-preservation-proof}

\subsection{Diamond lemma}

\LVarsLemDiamond
\input{chapter2/determinism-diamond-proof}

\subsection{Confluence lemmas}

\LVarsCorStrongLocalConfluence

\LVarsLemStrongOneSidedConfluence
\input{chapter2/determinism-strong-one-sided-confluence-proof}

\LVarsLemStrongConfluence

\TODO{proof}

\LVarsLemConfluence

\subsection{Determinism theorem}

\LVarsThmDeterminism

\subsection{Discussion: termination}

I have followed Budimli\'c \etal~\cite{CnC} in treating
\emph{determinism} separately from the issue of \emph{termination}.
Yet one might legitimately be concerned that in $\lambdaLVar$, a
configuration could have both an infinite reduction path and one that
terminates with a value.  Theorem~\ref{thm:lvars-determinism} says
that if two runs of a given $\lambdaLVar$ program reach configurations
where no more reductions are possible, then they have reached the same
configuration.  Hence Theorem~\ref{thm:lvars-determinism} handles the
case of \emph{deadlocks} already: a $\lambdaLVar$ program can deadlock
(\eg, with a blocked $\GET$), but it will do so deterministically.

However, Theorem~\ref{thm:lvars-determinism} has nothing to say about
\emph{livelocks}, in which a program reduces infinitely.  It would be
desirable to have a \emph{consistent termination} property which would
guarantee that if one run of a given $\lambdaLVar$ program terminates
with a non-$\error$ result, then every run will.  I conjecture (but do
not prove) that such a consistent termination property holds for
$\lambdaLVar$.  Such a property could be paired with
Theorem~\ref{thm:lvars-determinism} to guarantee that if one run of a
given $\lambdaLVar$ program terminates in a non-$\error$ configuration
$\sigma$, then every run of that program terminates in $\sigma$.  (The
``non-$\error$ configuration'' condition is necessary because it is
possible to construct a $\lambdaLVar$ program that can terminate in
$\error$ on some runs and diverge on others.  By contrast, the
existing determinism theorem does not have to treat $\error$
specially.)
