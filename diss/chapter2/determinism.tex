\section{Proof of determinism for
  $\lambdaLVar$}\label{s:lvars-proof}

The main technical result of this chapter is a proof of determinism
for the $\lambdaLVar$ language.  The determinism theorem says that if
two executions starting from a given configuration $\conf$ terminate
in configurations $\conf'$ and $\conf''$, then $\conf'$ and $\conf''$
are the same configuration, up to a permutation on locations.  (I
discuss permutations in more detail below, in
Section~\ref{subsection:lvars-permutations}.)

In order to prove determinism for $\lambdaLVar$, I first prove several
supporting lemmas.  The structure of the proof is similar to that of
the proof of determinism for Featherweight CnC given by Budimli\'c
\etal~\cite{CnC}.  I reuse the naming conventions of Budimli\'c
\etal~for Lemmas~\ref{lem:lvars-monotonicity}
through~\ref{lem:lvars-strong-local-confluence}, although the
statements and proofs of those lemmas differ considerably in the
setting of $\lambdaLVar$, due to the generality of LVars.

However, Lemmas~\ref{lem:lvars-strong-one-sided-confluence}
through~\ref{lem:lvars-confluence} are nearly identical to the
corresponding lemmas in the Featherweight CnC determinism proof.  This
is the case because, once Lemmas~\ref{lem:lvars-monotonicity} through
\ref{lem:lvars-strong-local-confluence} are established, the remainder
of the determinism proof does not need to deal specifically with the
semantics of LVars, lattices, or the store, and instead deals only
with execution steps at a high level.

\TODO{Say something about how later I'll show determinism for
  generalized monotonic writes and generalized threshold reads, if in
  fact I'm going to do that.}

\subsection{Permutations and permutability}\label{subsection:lvars-permutations}

The {\sc E-New} rule allocates a fresh location $l \in \Loc$ in the
store, with the only requirement on $l$ being that it is not (yet) in
the domain of the store.  Therefore, multiple runs of the same program
may differ in what locations they allocate, and therefore the
reduction semantics is nondeterministic with respect to allocation.
However, this is not a kind of nondeterminism that we care about, so
we work modulo an arbitrary \emph{permutation} on locations.

Recall from Section~\ref{subsection:lvars-stores} that we have a
countable set of locations $\Loc$.  Then, a permutation is defined as
follows:

\LVarsDefPermutation

Condition (1) in Definition~\ref{def:lvars-permutation} ensures that
we only consider location renamings that we can ``undo'', and
condition (2) ensures that we only consider renamings of a finite
number of locations.  Equivalently, we can say that $\pi$ is a
bijection from $\Loc$ to $\Loc$ such that it is the identity on all
but finitely many elements.

We can straightforwardly lift Definition~\ref{def:lvars-permutation}
to expressions and stores, and hence also to configurations.  To lift
a permutation $\pi$ to expressions, we over the syntax of terms
structurally and apply $\pi$ to any locations that occur in the term.
We can also lift $\pi$ to evaluation contexts, structurally: $\pi([~])
= [~]$, $\pi(\app{E}{e} = \app{\pi(E)}{\pi(e)}$, and so on.

To lift $\pi$ to stores, we apply $\pi$ to all locations in the domain
of the store.  (We do not have to do any renaming in the codomain of
the store, since locations cannot occur in elements of the
application-specific lattice $D$.)  Since $\pi$ is a bijection, it
follows that if some location $l$ is not in the domain of some store
$S$, then $\pi(l) \notin \dom{(\pi(S)}$,\lk{Do I need to spell out why
  this is true?} a fact that will be useful to us shortly.

\LVarsDefPermutationExpression

\LVarsDefPermutationStore

\LVarsDefPermutationConfiguration

With these definitions in place, I can show that transitions are
permutable:

\LVarsLemPermutability
\begin{proof}
  See Section~\ref{section:lvars-permutability-proof}.  The forward
  direction of part~\ref{thm:permutable-reduction-transitions} is by
  cases on the rule in the reduction semantics by which $\conf$ steps
  to $\conf'$; the only interesting case is the {\sc E-New} case, in
  which we make use of the fact that if $l \notin \dom{S}$, then
  $\pi(l) \notin \dom{\pi(S)}$. \TODO{Say something about
    Part~\ref{thm:permutable-context-transitions}.}
\end{proof}

\subsection{Internal determinism of the reduction semantics}

My goal is to show that $\lambdaLVar$ is deterministic according to
the definition of \emph{observable determinism} that I set forth in
Chapter~\ref{ch:intro}---that is, that a $\lambdaLVar$ program always
evaluates to the same value.  In the context of $\lambdaLVar$, a
``program'' can be understood as a configuration of a store and an
expression, and a ``value'' can be understood as a configuration that
cannot step.  A configuration that cannot step might be one in which
the expression is a value, or it might be a ``stuck'' configuration
that cannot step because no rule of the operational semantics applies,
even if the expression in that configuration is not a value.  (This
could happen if, for instance, we have a blocking @get@ expression and
there are no other evaluating expressions that could cause it to
unblock.)

This definition of observable determinism does not require that a
configuration takes the same sequence of steps on the way to reaching
its value at the end of every run, and in fact, the $\lambdaLVar$
operational semantics does not have that property.  I will use the
term \emph{internally deterministic} to describe a program that does,
in fact, takes the same sequence of steps on every run. \TODO{Get a
  citation for this.}  Although $\lambdaLVar$ is not internally
deterministic, all of the internal nondeterminism of $\lambdaLVar$ is
due to the {\sc E-Eval-Ctxt} rule!  This is the case because the {\sc
  E-Eval-Ctxt} rule is the only rule in the operational semantics by
which a particular configuration may be able to step in multiple ways.
The multiple ways in which a configuration can step via {\sc
  E-Eval-Ctxt} correspond to the ways in which the expression in that
configuration can be decomposed into a redex and an evaluation
context.  In fact, it is exactly this property that makes it possible
for multiple subexpressions of a $\lambdaLVar$ expression (a @let par@
expression, for instance) to be evaluated in parallel.

But, if we leave aside {\sc E-Eval-Ctxt} and focus on only the rules
of the reduction semantics in
Figure~\ref{f:lvars-lambdaLVar-reduction-semantics}, we see that there
is only one rule by which a given configuration can step, and only one
configuration to which it can step.  The exception is the {\sc E-New}
rule, which nondeterministically allocates locations and returns
pointers to them---but we can account for this by saying that the
reduction semantics is internally deterministic up to a permutation on
locations.  Lemma~\ref{lem:lvars-internal-determinism} formalizes this
claim.

\LVarsLemInternalDeterminism
\begin{proof}
  Straightforward by cases on the rule by which $\conf$ steps to
  $\conf'$; the only interesting case is for the {\sc E-New} rule.
  See Section~\ref{section:lvars-internal-determinism-proof}.
\end{proof}

\subsection{Monotonicity lemma}

\TODO{Figure out where this comes in, and how it needs to change.}

The Monotonicity lemma says that, as evaluation proceeds according to
the $\parstepsto$ relation, the store can only grow with respect to
the $\leqstore{}{}$ ordering.

\LVarsLemMonotonicity
\begin{proof}
  By induction on the derivation of $\config{S}{e} \parstepsto
  \config{S'}{e'}$, by cases on the last rule in the derivation; see
  Section~\ref{section:lvars-monotonicity-proof}.
\end{proof}

\subsection{Independence lemma}\label{subsection:lvars-independence}

\TODO{Figure out where this comes in, and how it needs to change.}

The Independence lemma establishes a ``frame property'' for
$\lambdaLVar$ that captures the idea that independent effects commute
with each other.  Consider an expression $e$ that runs starting in
store $S$ and steps to $e'$, updating the store to $S'$.  The
Independence lemma provides a double-edged guarantee about what will
happen if we evaluate $e$ starting from a larger store
$\lubstore{S}{S''}$: first, $e$ will update the store to
$\lubstore{S'}{S''}$; second, $e$ will step to $e'$ as it did before.
Here $\lubstore{S}{S''}$ is the least upper bound of the original $S$
and some other store $S''$ that is ``framed on'' to $S$; intuitively,
$S''$ is the store resulting from some other independently-running
computation.

Lemma~\ref{lem:lvars-independence} requires as a precondition that the
store $S''$ must be \emph{non-conflicting} with the original
transition from $\config{S}{e}$ to $\config{S'}{e'}$, meaning that
locations in $S''$ cannot share names with locations newly allocated
during the transition; this rules out location name conflicts caused
by allocation.

\LVarsDefNonConflicting

\LVarsLemIndependence
\begin{proof}
  By induction on the derivation of $\config{S}{e} \parstepsto
  \config{S'}{e'}$, by cases on the last rule in the derivation; see
  Section~\ref{section:lvars-independence-proof}.
\end{proof}

\subsection{Clash lemma}

The Clash lemma, Lemma~\ref{lem:lvars-clash}, is similar to the
Independence lemma, but handles the case where $\lubstore{S'}{S''} =
\topS$.  It establishes that, in that case,
$\config{\lubstore{S}{S''}}{e}$ steps to $\error$.

\lk{We didn't need the Clash lemma for the quasi-determinism proof,
  but I'm pretty sure the only reason we didn't need it was because
  quasi-determinism is ``...or $\error$''.  I think we actually do
  need it here.}

\LVarsLemClash
\begin{proof}
  By induction on the derivation of $\config{S}{e} \parstepsto
  \config{S'}{e'}$, by cases on the last rule in the derivation; see
  Section~\ref{section:lvars-clash-proof}.
\end{proof}

\subsection{Error Preservation lemma}

Lemma~\ref{lem:lvars-error-preservation}, Error Preservation, says
that if a configuration $\config{S}{e}$ steps to $\error$, then
evaluating $e$ in the context of some larger store will also result in
$\error$.

\lk{We didn't need the Error Preservation lemma for the
  quasi-determinism proof, but I'm pretty sure the only reason we
  didn't need it was because quasi-determinism is ``...or $\error$''.
  I think we actually do need it here.}

\LVarsLemErrorPreservation
\begin{proof}
  By induction on the derivation of $\config{S}{e} \parstepsto
  \error$, by cases on the last rule in the derivation; see
  Section~\ref{section:lvars-error-preservation-proof}.
\end{proof}

\subsection{Confluence lemmas}\label{subsection:lvars-confluence}

Lemma~\ref{lem:lvars-strong-local-confluence}, the Strong Local
Confluence lemma, says that if a configuration $\conf$ can step to
configurations $\conf_a$ and $\conf_b$, then there exists an
configuration $\conf_c$ that $\conf_a$ and $\conf_b$ can each reach in
at most one step, modulo a permutation on the locations in $\conf_b$.
Lemmas~\ref{lem:lvars-strong-one-sided-confluence}
and~\ref{lem:lvars-strong-confluence} then generalize that result to
arbitrary numbers of steps.

The structure of this part of the proof differs slightly from the
Budimli\'c \etal~determinism proof for Featherweight CnC.  Budimli\'c
\etal~prove a \emph{diamond} property, in which $\conf_a$ and
$\conf_b$ each step to $\conf_c$ in \emph{exactly} one step.  They
then get a property like Lemma~\ref{lem:lvars-strong-local-confluence}
as an immediate consequence of the diamond property, by choosing $i =
j = 1$.  But a true diamond property with exactly one step ``on each
side of the diamond'' is stronger than we need here, and, in fact,
does not hold for $\lambdaLVar$; so, instead, I prove the weaker ``at
most one step'' property directly.

\LVarsLemStrongLocalConfluence
\begin{proof}
  By induction on the derivation of $\conf \parstepsto \conf_a$, by
  cases on the last rule in the derivation; see
  Section~\ref{section:lvars-strong-local-confluence-proof}.
\end{proof}

\LVarsLemStrongOneSidedConfluence
\begin{proof}
  By induction on $m$; see
  Section~\ref{section:lvars-strong-one-sided-confluence-proof}.
\end{proof}

\LVarsLemStrongConfluence
\begin{proof}
  By induction on $n$; see
  Section~\ref{section:lvars-strong-confluence-proof}.
\end{proof}

\LVarsLemConfluence

\subsection{Determinism theorem}

Finally, the determinism theorem, Theorem~\ref{thm:lvars-determinism},
is a direct result of Lemma~\ref{lem:lvars-confluence}:

\LVarsThmDeterminism

\subsection{Discussion: termination}

I have followed Budimli\'c \etal~\cite{CnC} in treating
\emph{determinism} separately from the issue of \emph{termination}.
Yet one might legitimately be concerned that in $\lambdaLVar$, a
configuration could have both an infinite reduction path and one that
terminates with a value.  Theorem~\ref{thm:lvars-determinism} says
that if two runs of a given $\lambdaLVar$ program reach configurations
where no more reductions are possible, then they have reached the same
configuration.  Hence Theorem~\ref{thm:lvars-determinism} handles the
case of \emph{deadlocks} already: a $\lambdaLVar$ program can deadlock
(\eg, with a blocked $\GET$), but it will do so deterministically.

However, Theorem~\ref{thm:lvars-determinism} has nothing to say about
\emph{livelocks}, in which a program reduces infinitely.  It would be
desirable to have a \emph{consistent termination} property which would
guarantee that if one run of a given $\lambdaLVar$ program terminates
with a non-$\error$ result, then every run will.  I conjecture (but do
not prove) that such a consistent termination property holds for
$\lambdaLVar$.  Such a property could be paired with
Theorem~\ref{thm:lvars-determinism} to guarantee that if one run of a
given $\lambdaLVar$ program terminates in a non-$\error$ configuration
$\sigma$, then every run of that program terminates in $\sigma$.  (The
``non-$\error$ configuration'' condition is necessary because it is
possible to construct a $\lambdaLVar$ program that can terminate in
$\error$ on some runs and diverge on others.  By contrast, the
existing determinism theorem does not have to treat $\error$
specially.)
