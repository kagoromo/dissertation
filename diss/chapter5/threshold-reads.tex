\subsection{Threshold queries of an \il{AndLV}}

Given that we want the result of a threshold query to be a deterministic
function of the writes to a data structure---and not of the particular moment in
time the query is made---what sorts of observations are safe to make of an \il{AndLV}?
We cannot, for instance, test whether one or both inputs have been
written at a particular point in time, because the result will 
depend on how the test is interleaved with the writes.

Instead, we can describe a \emph{partial function} of the data
structure's state that is undefined for all states except those that
are at or above a certain \emph{threshold} in the lattice.
One way to describe such a function is to define a \emph{threshold
  set} of sets of ``activation'' states.  In the case of our
\il{AndLV}, one of these sets of activation states is the set of
states containing an \il{F}---that is, the set $\{
\textrm{\il{(F,Bot)}, \il{(Bot,F)}, \il{(F,T)}, \il{(T,F)},
  \il{(F,F)}} \}$.  The elements of this set are shown in red in
Figure~\ref{f:parallel-and}.  The other set of activation states
singleton set $\{ \textrm{\il{(T,T)}} \}$, shown in green in
Figure~\ref{f:parallel-and}.  Therefore the entire threshold set is
\[
\{ 
\{ \textrm{\il{(F,Bot)}, \il{(Bot,F)}, \il{(F,T)}, \il{(T,F)}, \il{(F,F)}} \},
\{ \textrm{\il{(T,T)}} \}
\}
\]
The semantics of a threshold query is as follows: if a data structure's state
reaches (or surpasses) any state or states in a particular set of activation
states, the threshold query returns \emph{the entire set} of
activation states, regardless of which of those activation states was reached. If
no state in any set of activation states has yet been reached, the
threshold query will \emph{block}; blocking corresponds to states on
which the partial function is undefined.

In the case of our \il{AndLV}, as soon as either input writes an
\il{F}, our threshold query will unblock and return the first set of
activation states, that is, $\{ \textrm{\il{(F,Bot)}, \il{(Bot,F)},
  \il{(F,T)}, \il{(T,F)}, \il{(F,F)}} \}$.  Hence \il{AndLV} has the
expected ``short-circuit'' behavior and does not have to wait for a
second input if the first input is \il{F}.  If, on the other hand, both
inputs write a \il{T}, the threshold query will unblock and return $\{
\textrm{\il{(T,T)}} \}$.

In a real implementation,
of course, the value returned from the query could be more meaningful
to the client---for instance, we could return \il{False}
instead of returning the set of activation states.  However,
doing so would only be a convenience, and the translation from $\{
\textrm{\il{(F,Bot)}, \il{(Bot,F)}, \il{(F,T)}, \il{(T,F)},
  \il{(F,F)}} \}$ to \il{False} could just as easily take place on the
client side.  In either case, the result returned from the
threshold query is the same regardless of \emph{which} of the activation
states caused it to unblock, and it is impossible for the client to
tell whether the actual state of the lattice is, say, \il{(T,F)} or
\il{(F,F)} or some other state containing \il{F}.

\subsection{Pairwise incompatibility}\label{subsec:pairwise-incompatibility}

In order for the behavior of a threshold query
to be deterministic, it must be unblocked by
a \emph{unique} set of activation states in the threshold set.  
We ensure this by
requiring that elements in a set of activation states must be
\emph{pairwise incompatible} with elements in every other set of
activation states.  That is, for all distinct sets of activation states $Q$
and $R$ in a given threshold set: $\forall q \in Q.~\forall r \in R.~q \sqcup r = \top$.
\lk{changed to inline math to save space.}
%% %
%% \[ \forall q \in Q.~\forall r \in R.~q \sqcup r = \top \]
%% %
In our \il{AndLV} example, there are two distinct sets of activation states, so if
we let $Q = \{ \textrm{\il{(T,T)}} \}$ and $R = \{
\textrm{\il{(F,Bot)}, \il{(Bot,F)}, \il{(F,T)}, \il{(T,F)},
  \il{(F,F)}} \}$, the least upper bound of \il{(T,T)} and $r$ must be
\il{Top}, where $r$ is any element of $R$.  We can easily verify that
this is the case.  Furthermore, since the lattice of states that an
\il{AndLV} can take on is finite, the join function can be verified to compute a
least upper bound.

Why is pairwise incompatibility necessary?  Consider the following
(illegal) ``threshold set'' that does not meet the pairwise
incompatibility criterion:
$ \{ \{ \textrm{\il{(F,Bot)}, \il{(Bot,F)}} \},  \{ \textrm{\il{(T,Bot)}, \il{(Bot,T)}} \} \} $.
\lk{changed to inline math to save space.}
%% \[
%% \{ 
%% \{ \textrm{\il{(F,Bot)}, \il{(Bot,F)}} \},
%% \{ \textrm{\il{(T,Bot)}, \il{(Bot,T)}} \}
%% \}
%% \]
A threshold query corresponding to this so-called threshold set will
unblock and return $\{ \textrm{\il{(F,Bot)}, \il{(Bot,F)}} \}$
as soon as a state containing an
\il{F} is reached, and $\{ \textrm{\il{(T,Bot)}, \il{(Bot,T)}} \}$
as soon as a state
containing a \il{T} is reached.  The trouble with such a threshold
query is that there exist states, such as \il{(F,T)} and \il{(T,F)},
that could unblock either set of activation states.  If the left input
writes \il{F} and the right input writes \il{T}, and these writes
occur in arbitrary order, then the threshold query will return a
nondeterministic result, depending on the order in which the two
writes arrive.  But with the original, pairwise-incompatible threshold
set we showed, the threshold query would deterministically return
\il{False}---although if the \il{T} arrived first, the query would
have to block until the \il{F} arrived, whereas if the \il{F} arrived
first, it could unblock immediately.  Hence threshold queries enforce
consistency at the expense of availability, but it is still possible
to do a ``short-circuit'' computation that unblocks as soon as an
\il{F} is written.

The threshold set mechanism we describe in this section is 
part of the LVars programming model discussed in
section~\ref{s:intro}; in fact, our \il{AndLV} example is precisely an
LVar~\cite{effectzoo}.  But the utility of threshold queries
is not limited to LVars.  In
the following sections, we review the basics of the CvRDT model from the work of
Shapiro \etal, then show how to add threshold queries to the CvRDT
model, and prove that they are strongly
consistent queries.

