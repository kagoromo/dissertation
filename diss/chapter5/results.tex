\section{Determinism of threshold queries}\label{s:results}

Neither eventual consistency nor strong eventual consistency imply
that \emph{intermediate} results of the same query $q$ on different
replicas of a threshold CvRDT will be deterministic.  For
deterministic intermediate results, we must use the threshold query
method $t$.  We can show that $t$ is deterministic \emph{without}
requiring that the same updates have been delivered at the replicas in
question at the time that $t$ runs.

In our previous work on LVars~\cite{LVars-paper,Freeze-paper}, we
showed that a threshold read of the contents of a shared-memory
lattice-based data structure returns a deterministic result regardless
of how that query is interleaved with updates to the data structure.
Theorem~\ref{thm:determinism-of-threshold-queries} establishes that
the same is true for threshold queries of \emph{distributed,
  replicated} lattice-based data structures---namely, threshold
CvRDTs.

\begin{thm}[Determinism of Threshold Queries]
  \label{thm:determinism-of-threshold-queries}
  Suppose a given threshold query $t$ on a given threshold CvRDT
  returns a set of activation states $S_a$ when executed at a replica
  $i$.  Then, assuming eventual delivery and that no replica's state
  is ever $\top$ at any point in the execution:
  \begin{enumerate}
  \item \label{thm:this-replica} $t$ will always return $S_a$ on
    subsequent executions at $i$, and
  \item \label{thm:any-replica} $t$ will \emph{eventually} return
    $S_a$ when executed at \emph{any} replica, and will \emph{block}
    until it does so.
  \end{enumerate}
\end{thm}
\begin{proof}
Consider replica $i$ of a threshold CvRDT $(S, \leq, s^0, q, t, u,
m)$.  Let $\mathcal{S}$ be a threshold set with respect to
$(S, \leq)$.  Consider a method execution $t^{k+1}_i(\mathcal{S})$
(\ie, a threshold query that is the $k+1$th method execution
on replica $i$, with threshold set $\mathcal{S}$ as its argument) that
returns some set of activation states $S_a \in \mathcal{S}$.

For part~\ref{thm:this-replica} of the theorem, we have to show that
threshold queries with $\mathcal{S}$ as their argument will always
return $S_a$ on subsequent executions at $i$.  That is, we have to
show that, for all $k' > (k+1)$, the threshold query
$t^{k'}_i(\mathcal{S})$ on $i$ returns $S_a$.

Since $t^{k+1}_i(\mathcal{S})$ returns $S_a$, from
Definition~\ref{def:cvrdt-with-threshold-queries} we have that for
some activation state $s_a \in S_a$, the condition $s_a \leq s^k_i$
holds.  Consider arbitrary $k' > (k+1)$.  Since state is inflationary
across updates, we know that the state $s^{k'}_i$ after method
execution $k'$ is at least $s^k_i$.  That is, $s^k_i \leq s^{k'}_i$.
By transitivity of $\leq$, then, $s_a \leq s^{k'}_i$.  Hence, by
Definition~\ref{def:cvrdt-with-threshold-queries},
$t^{k'}_i(\mathcal{S})$ returns $S_a$.

For part~\ref{thm:any-replica} of the theorem, consider some replica
$j$ of $(S, \leq, s^0, q, t, u, m)$, located at process $p_j$.
We are required to show that, for all
$x \geq 0$, the threshold query $t^{x+1}_j(\mathcal{S})$ returns $S_a$ eventually, and blocks
until it does.\footnote{The occurrences of $k+1$ and $x+1$ in this
proof are an artifact of how we index method executions starting from
$1$, but states starting from $0$.  The initial state (of every
replica) is $s^0$, and so $s^k_i$ is the state of replica $i$ after method
execution $k$ has completed at $i$.}
% 
That is, we must show that, for all $x \geq 0$, there exists some
finite $n \geq 0$ such that
\begin{itemize}
\item 
for all $i$ in the range $0 \leq i \leq n-1$, the threshold query
$t^{x+1+i}_j(\mathcal{S})$ returns $\block$, and
\item
for all $i \geq n$, the threshold query $t^{x+1+i}_j(\mathcal{S})$
returns $S_a$.
\end{itemize}
Consider arbitrary $x \geq 0$.  Recall that $s^x_j$ is the state of
replica $j$ after the $x$th method execution, and therefore $s^x_j$ is
also the state of $j$ when $t^{x+1}_j(\mathcal{S})$ runs.
%
We have three cases to consider:
\begin{itemize}
\item $s^k_i \leq s^x_j$.
(That is, replica $i$'s state after the $k$th method execution on $i$
is \emph{at or below} replica $j$'s state after the $x$th method
execution on $j$.)
%
Choose $n = 0$.  We have to show that, for all $i \geq n$, the
threshold query $t^{x+1+i}_j(\mathcal{S})$ returns $S_a$.  Since
$t^{k+1}_i(\mathcal{S})$ returns $S_a$, we know that there exists an
$s_a \in S_a$ such that $s_a \leq s^k_i$.  Since $s^k_i \leq s^x_j$,
we have by transitivity of $\leq$ that $s_a \leq s^x_j$.  Therefore,
by Definition~\ref{def:cvrdt-with-threshold-queries},
$t^{x+1}_j(\mathcal{S})$ returns $S_a$.  Then, by
part~\ref{thm:this-replica} of the theorem, we have that subsequent
executions $t^{x+1+i}_j(\mathcal{S})$ at replica $j$ will also return
$S_a$, and so the case holds.  (Note that this case includes the
possibility $s^k_i \equiv s^0$, in which no updates have executed at
replica $i$.)

\item $s^k_i > s^x_j$.
(That is, replica $i$'s state after the $k$th method execution on $i$
is \emph{above} replica $j$'s state after the $x$th method execution
on $j$.)

  We have two subcases:

\begin{itemize}
\item
There exists some activation state $s'_a \in S_a$ for which $s'_a \leq
s^x_j$.  In this case, we choose $n = 0$.  We have to show that, for
all $i \geq n$, the threshold query $t^{x+1+i}_j(\mathcal{S})$ returns
$S_a$.  Since $s'_a \leq s^x_j$, by
Definition~\ref{def:cvrdt-with-threshold-queries},
$t^{x+1}_j(\mathcal{S})$ returns $S_a$.  Then, by
part~\ref{thm:this-replica} of the theorem, we have that subsequent
executions $t^{x+1+i}_j(\mathcal{S})$ at replica $j$ will also return
$S_a$, and so the case holds.

\item
There is no activation state $s'_a \in S_a$ for which $s'_a \leq
s^x_j$.  Since $t^{k+1}_i(\mathcal{S})$ returns $S_a$, we know that
there is some update $u^{k'}_i(a)$ in $i$'s causal history, for some
$k' < (k+1)$, that updates $i$ from a state at or below $s^x_j$ to
$s^k_i$.\footnote{We know that $i$'s state was once at or below
$s^x_j$, because $i$ and $j$ started at the same state $s^0$ and can
both only grow.  Hence the least that $s^x_j$ can be is $s^0$, and we
know that $i$ was originally $s^0$ as well.} By eventual delivery,
$u^{k'}_i(a)$ is eventually delivered at $j$.  Hence some update or
updates that will increase $j$'s state from $s^x_j$ to a state at or
above some $s'_a$ must reach replica $j$.\footnote{We say ``some
update or updates'' because the exact update $u^{k'}_i(a)$ may not be
the update that causes the threshold query at $j$ to unblock; a
different update or updates could do it.  Nevertheless, the existence
of $u^{k'}_i(a)$ means that there is at least one update that will
suffice to unblock the threshold query.}

Let the $x+1+r$th method execution on $j$ be the first update on $j$
that updates its state to some $s^{x+1+r}_j \geq s'_a$, for some
activation state $s'_a \in S_a$.  Choose $n = r+1$.  We have to show that, for
all $i$ in the range $0 \leq i \leq r$, the threshold query
$t^{x+1+i}_j(\mathcal{S})$ returns $\block$, and that for all $i \geq
r+1$, the threshold query $t^{x+1+i}_j(\mathcal{S})$ returns $S_a$.

For the former, since the $x+1+r$th method execution on $j$ is the
first one that updates its state to $s^{x+1+r}_j \geq s'_a$, we have
by Definition~\ref{def:cvrdt-with-threshold-queries} that for all $i$
in the range $0 \leq i \leq r$, the threshold query
$t^{x+1+i}_j(\mathcal{S})$ returns $\block$.

For the latter, since $s^{x+1+r}_j \geq s'_a$, by
Definition~\ref{def:cvrdt-with-threshold-queries} we have that
$t^{x+1+r+1}_j(\mathcal{S})$ returns $S_a$, and by
part~\ref{thm:this-replica} of the theorem, we have that for $i \geq
r+1$, subsequent executions $t^{x+1+i}_j(\mathcal{S})$ at replica $j$
will also return $S_a$, and so the case holds.
\end{itemize}

\item $s^k_i \nleq s^x_j$ and $s^x_j \nleq s^k_i$.
(That is, replica $i$'s state after the $k$th method execution on $i$
is \emph{not comparable} to replica $j$'s state after the $x$th method
execution on $j$.)  Similar to the previous case.
\end{itemize}
\end{proof}

Although Theorem~\ref{thm:determinism-of-threshold-queries} must
assume eventual delivery, it does \emph{not} need to assume strong
convergence or even ordinary convergence.  It so happens that we have
strong convergence as part of strong eventual consistency of threshold
CvRDTs (by
Theorem~\ref{thm:strong-eventual-consistency-of-threshold-cvrdts}),
but we do not need it to prove
Theorem~\ref{thm:determinism-of-threshold-queries}.  In particular,
there is no need for replicas to have the same state in order to
return the same result from a particular threshold query.  The
replicas merely both need to be above an activation state from a
unique set of activation states in the query's threshold set.  Indeed,
the replicas' states may in fact trigger \emph{different} activation
states from the same set of activation states.

Theorem~\ref{thm:determinism-of-threshold-queries}'s requirement that
no replica's state is ever $\top$ rules out situations in which
replicas disagree in a way that cannot be resolved normally.  This
would happen if, for instance, updates at two different replicas took
their states to activation states from two distinct sets of activation
states from the same threshold set.  The join of the two replicas'
states would be $\top$, which by eventual delivery would become the
state of both replicas, but in the meantime, threshold queries of the
two replicas would return different results.  We rule out this
situation by assuming that no replica's state goes to $\top$.  (In a
replicated version of the parallel ``and'' example from
Section~\ref{s:threshold-reads}, this would happen if, for instance,
one replica received a write of \il{T} on its left input while another
received a write of \il{F}, also on its left input---a disagreement
for which the only resolution is the error state, \il{Top}).
