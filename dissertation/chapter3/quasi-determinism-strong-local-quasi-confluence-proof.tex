\begin{proof}
  Suppose $\conf \ctxstepsto \conf_a$ and $\conf \ctxstepsto \conf_b$.
  We have to show that either there exist $\conf_c, i, j, \pi$ such
  that $\conf_a \ctxstepsto^i \conf_c$ and $\pi(\conf_b) \ctxstepsto^j
  \conf_c$ and $i \leq 1$ and $j \leq 1$, or that $\conf_a \ctxstepsto
  \error$ or $\conf_b \ctxstepsto \error$.

  By inspection of the operational semantics, it must be the case that
  $\conf$ steps to $\conf_a$ by the {\sc E-Eval-Ctxt} rule.  Let
  $\conf = \config{S}{\evalctxt{E_a}{e_{a_1}}}$ and let $\conf_a =
  \config{S_a}{\evalctxt{E_a}{e_{a_2}}}$.

  Likewise, it must be the case that $\conf$ steps to $\conf_b$ by the
  {\sc E-Eval-Ctxt} rule.  Let $\conf =
  \config{S}{\evalctxt{E_b}{e_{b_1}}}$ and let $\conf_b =
  \config{S_b}{\evalctxt{E_b}{e_{b_2}}}$.

  Note that $\conf = \config{S}{\evalctxt{E_a}{e_{a_1}}} =
  \config{S}{\evalctxt{E_b}{e_{b_1}}}$, and so
  $\evalctxt{E_a}{e_{a_1}} = \evalctxt{E_b}{e_{b_1}}$, but $E_a$ and
  $E_b$ may differ and $e_{a_1}$ and $e_{b_1}$ may differ.

  Since $\config{S}{\evalctxt{E_a}{e_{a_1}}} \ctxstepsto
  \config{S_a}{\evalctxt{E_a}{e_{a_2}}}$ and
  $\config{S}{\evalctxt{E_b}{e_{b_1}}} \ctxstepsto
  \config{S_b}{\evalctxt{E_b}{e_{b_2}}}$ and $\evalctxt{E_a}{e_{a_1}}
  = \evalctxt{E_b}{e_{b_1}}$, we have from Lemma~\ref{lem:locality}
  (Locality) that there exist evaluation contexts $E'_a$ and $E'_b$
  such that:

  \begin{itemize}
  \item $\evalctxt{E'_a}{e_{a_1}} = \evalctxt{E_b}{e_{b_2}}$, and
  \item $\evalctxt{E'_b}{e_{b_1}} = \evalctxt{E_a}{e_{a_2}}$, and
  \item $\evalctxt{E'_a}{e_{a_2}} =
  \evalctxt{E'_b}{e_{b_2}}$.
  \end{itemize}

  \TODO{Audit this prose when the proof is done.}
  In some of the cases that follow, we will show that $\conf_a
  \ctxstepsto \error$ or that $\conf_b \ctxstepsto \error$.  In
  others, we will choose $\conf_c = \error$.  In most cases, however,
  our approach will be to show that there exist $S', i, j, \pi$ such
  that:
  \begin{itemize}
  \item $\config{S_a}{\evalctxt{E_a}{e_{a_2}}} \ctxstepsto^i
    \config{S'}{\evalctxt{E'_a}{e_{a_2}}}$, and
  \item $\pi(\config{S_b}{\evalctxt{E_b}{e_{b_2}}}) \ctxstepsto^j
    \config{S'}{\evalctxt{E'_a}{e_{a_2}}}$.
  \end{itemize}
  Since $\evalctxt{E'_a}{e_{a_1}} = \evalctxt{E_b}{e_{b_2}}$,
  $\evalctxt{E'_b}{e_{b_1}} = \evalctxt{E_a}{e_{a_2}}$, and
  $\evalctxt{E'_a}{e_{a_2}} = \evalctxt{E'_b}{e_{b_2}}$, it suffices
  to show that:
  \begin{itemize}
  \item $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto^i
    \config{S'}{\evalctxt{E'_b}{e_{b_2}}}$, and
  \item $\pi(\config{S_b}{\evalctxt{E'_a}{e_{a_1}}}) \ctxstepsto^j
    \config{S'}{\evalctxt{E'_a}{e_{a_2}}}$.
  \end{itemize}
  From the premise of {\sc E-Eval-Ctxt}, we have that
  $\config{S}{e_{a_1}} \parstepsto \config{S_a}{e_{a_2}}$ and
  $\config{S}{e_{b_1}} \parstepsto \config{S_b}{e_{b_2}}$.  We proceed
  by case analysis on the rule by which $\config{S}{e_{a_1}}$ steps to
  $\config{S_a}{e_{a_2}}$.  Since the only way an $\error$
  configuration can arise is by the {\sc E-Put-Err} rule, we can
  assume in all other cases that $\conf_a \neq \error$.

  \begin{enumerate}
  \item Case {\sc E-Beta}: We have $S_a = S$.

    We proceed by case analysis on the rule by which
    $\config{S}{e_{b_1}}$ steps to $\config{S_b}{e_{b_2}}$.  Since the
    only way an $\error$ configuration can arise is by the {\sc
      E-Put-Err} rule, we can assume in all other cases that $\conf_b
    \neq \error$.
    \begin{enumerate}
    \item \label{slqc-beta-beta}Case {\sc E-Beta}: We have $S_a = S$
      and $S_b = S$.

      Choose $S' = S = S_a = S_b$, $i = 1$, $j = 1$, and $\pi = \id$.

      We have to show that:
      \begin{itemize}
      \item $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \config{S_a}{\evalctxt{E'_b}{e_{b_2}}}$, and
      \item $\config{S}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$, 
      \end{itemize}

      both of which follow immediately from $\config{S}{e_{a_1}}
      \parstepsto \config{S_a}{e_{a_2}}$ and $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$ and {\sc E-Eval-Ctxt}.

    \item \label{slqc-beta-new}Case {\sc E-New}: We have $S_a = S$ and
      $S_b = \extS{S}{l}{\bot}{\frozenfalse}$.

      Choose $S' = S_b$, $i = 1$, $j = 1$, and $\pi = \id$.

      We have to show that:
      \begin{itemize}
      \item $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_b}{e_{b_2}}}$, and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$.
      \end{itemize}

      The first of these follows immediately from $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$ and {\sc E-Eval-Ctxt}.  For
      the second, consider that $S_b = \extS{S}{l}{\bot}{\frozenfalse}
      = U_S(S)$, where $U_S$ is the store update operation that acts
      as the identity on the contents of all existing locations, and
      adds the binding $\storebinding{l}{\bot}{\frozenfalse}$ if no
      binding for $l$ exists.  Note that:
      \begin{itemize}
      \item $U_S$ is non-conflicting with $\config{S}{e_{a_1}}
        \parstepsto \config{S_a}{e_{a_2}}$, since no locations are
        allocated during the transition;
        \item $U_S(S_a) \neq \topS$, since $U_S(S_a) = U_S(S) = S_b$
          and we know that $\conf_b \neq \error$; and
        \item $U_S$ is freeze-safe with $\config{S}{e_{a_1}}
          \parstepsto \config{S_a}{e_{a_2}}$, since $S_a = S$, so
          there are no locations whose contents differ in status
          between them.
      \end{itemize}

      Therefore, by Lemma~\ref{lem:generalized-independence}
      (Generalized Independence), we have that
      $\config{U_S(S)}{e_{a_1}} \parstepsto
      \config{U_S(S_a)}{e_{a_2}}$.  Hence $\config{S_b}{e_{a_1}}
      \parstepsto \config{S_b}{e_{a_2}}$.  By {\sc E-Eval-Ctxt}, it
      follows that $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
      \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$, as we were required to
      show.

    \item \label{slqc-beta-put}Case {\sc E-Put}: We have $S_a = S$ and
      $S_b = \extSRaw{S}{l}{u_{p_i}(p_1)}$.

      Choose $S' = S_b$, $i = 1$, $j = 1$, and $\pi = \id$.

      We have to show that:
      \begin{itemize}
      \item $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_b}{e_{b_2}}}$, and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$.
      \end{itemize}

      The first of these follows immediately from $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$ and {\sc E-Eval-Ctxt}.  For
      the second, consider that $S_b = U_S(S)$, where $U_S$ is the
      store update operation that applies $u_{p_i}$ to the contents of
      $l$ and acts as the identity on all other locations.  Note that:
      \begin{itemize}
      \item $U_S$ is non-conflicting with $\config{S}{e_{a_1}}
        \parstepsto \config{S_a}{e_{a_2}}$, since no locations are
        allocated during the transition;
        \item $U_S(S_a) \neq \topS$, since $U_S(S_a) = U_S(S) = S_b$
          and we know that $\conf_b \neq \error$; and
        \item $U_S$ is freeze-safe with $\config{S}{e_{a_1}}
          \parstepsto \config{S_a}{e_{a_2}}$, since $S_a = S$, so
          there are no locations whose contents differ in status
          between them.
      \end{itemize}

      Therefore, by Lemma~\ref{lem:generalized-independence}
      (Generalized Independence), we have that
      $\config{U_S(S)}{e_{a_1}} \parstepsto
      \config{U_S(S_a)}{e_{a_2}}$.  Hence $\config{S_b}{e_{a_1}}
      \parstepsto \config{S_b}{e_{a_2}}$.  By {\sc E-Eval-Ctxt}, it
      follows that $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
      \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$, as we were required to
      show.

    \item \label{slqc-beta-put-err}Case {\sc E-Put-Err}: We have $S_a
      = S$ and $\config{S_b}{e_{b_2}} = \error$, and so we choose
      $\conf_c = \error$, $i = 1$, $j = 0$, and $\pi = \id$.  We have
      to show that:
      \begin{itemize}
      \item $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto \error$,
        and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} = \error$.
      \end{itemize}

      The second of these is immediately true because since
      $\config{S_b}{e_{b_2}} = \error$, $S_b = \topS$, and so
      $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}}$ is equal to $\error$ as
      well.  For the first, observe that $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$, hence by {\sc E-Eval-Ctxt},
      $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
      \config{S_b}{\evalctxt{E'_b}{e_{b_2}}}$.  But $S_b = \topS$, so
      $\config{S_b}{\evalctxt{E'_b}{e_{b_2}}}$ is equal to $\error$,
      and so $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
      \error$, as required.

    \item \label{slqc-beta-get}Case {\sc E-Get}: Similar to
      case~\ref{slqc-beta-beta}, since $S_a = S$ and $S_b = S$.
    \item \label{slqc-beta-freeze-init}Case {\sc E-Freeze-Init}:
      Similar to case~\ref{slqc-beta-beta}, since $S_a = S$ and $S_b =
      S$.
    \item \label{slqc-beta-spawn-handler}Case {\sc E-Spawn-Handler}:
      Similar to case~\ref{slqc-beta-beta}, since $S_a = S$ and $S_b =
      S$.
    \item \label{slqc-beta-freeze-final}Case {\sc E-Freeze-Final}: We
      have $S_a = S$ and $S_b = \extS{S}{l}{d_1}{\frozentrue}$.

      Choose $S' = S_b$, $i = 1$, $j = 1$, and $\pi = \id$.

      We have to show that:
      \begin{itemize}
      \item $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_b}{e_{b_2}}}$, and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$.
      \end{itemize}

      The first of these follows immediately from $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$ and {\sc E-Eval-Ctxt}.  For
      the second, since $\config{S}{e_{a_1}} \parstepsto
      \config{S_a}{e_{a_2}}$ by {\sc E-Beta}, by inspection of the
      operational semantics we have that $e_{a_1} =
      \app{(\lam{x}{e})}{v}$ and $e_{a_2} = \subst{e}{x}{v}$.  Hence,
      by {\sc E-Beta}, $\config{S_b}{e_{a_1}} \parstepsto
      \config{S_b}{e_{a_2}}$.  Hence, by {\sc E-Eval-Ctxt},
      $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \parstepsto
      \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$, as we were required to
      show.

      \lk{Here in {\sc E-Beta} we could've done that with the other
        cases, too, instead of appealing to Independence...}

    \item \label{slqc-beta-freeze-simple}Case {\sc E-Freeze-Simple}:
      Similar to case~\ref{slqc-beta-freeze-final}, since $S_b =
      \extS{S}{l}{d_1}{\frozentrue}$.

    \end{enumerate}
  \item Case {\sc E-New}: We have $S_a = \extS{S}{l}{\bot}{\frozenfalse}$.

    We proceed by case analysis on the rule by which
    $\config{S}{e_{b_1}}$ steps to $\config{S_b}{e_{b_2}}$.  Since the
    only way an $\error$ configuration can arise is by the {\sc
      E-Put-Err} rule, we can assume in all other cases that $\conf_b
    \neq \error$.
    \begin{enumerate}
    \item \label{slqc-new-beta}Case {\sc E-Beta}: By symmetry with case~\ref{slqc-beta-new}.
    \item \label{slqc-new-new}Case {\sc E-New}: We have $S_a =
      \extS{S}{l}{\bot}{\frozenfalse}$ and $S_b =
      \extS{S}{l'}{\bot}{\frozenfalse}$.

      Now consider whether $l = l'$:
      \begin{itemize}
        \item If $l \neq l'$:

          Choose $S' =
          \extS{\extS{S}{l'}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}$,
          $i = 1$, $j = 1$, and $\pi = \id$.

          We have to show that:
          \begin{itemize}
          \item
            $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
            \config{\extS{\extS{S}{l'}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{e_{b_2}}}$,
            and
          \item
            $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
            \config{\extS{\extS{S}{l'}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_a}{e_{a_2}}}$.
          \end{itemize}

          For the first of these, consider that $S_a =
          \extS{S}{l}{\bot}{\frozenfalse} = U_S(S)$, where $U_S$ is
          the store update operation that acts as the identity on the
          contents of all existing locations, and adds the binding
          $\storebinding{l}{\bot}{\frozenfalse}$ if no binding for $l$
          exists.  Note that:
          \begin{itemize}
          \item $U_S$ is non-conflicting with $\config{S}{e_{b_1}}
            \parstepsto \config{S_b}{e_{b_2}}$, since the only
            location allocated during the transition is $l'$, and $l
            \neq l'$ in this case;
          \item $U_S(S_b) \neq \topS$, since $U_S(S_b) =
            \extS{\extS{S}{l'}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}$
            and we know $S \neq \topS$ and the addition of new
            bindings $\storebinding{l}{\bot}{\frozenfalse}$ and
            $\storebinding{l'}{\bot}{\frozenfalse}$ cannot cause it to
            become $\topS$; and
          \item $U_S$ is freeze-safe with $\config{S}{e_{b_1}}
            \parstepsto \config{S_b}{e_{b_2}}$, since $S_b =
            \extS{S}{l'}{\bot}{\frozenfalse}$ and $l' \notin \dom{S}$,
            so there are no locations whose contents differ in status
            between $S$ and $S_b$.
          \end{itemize}

          Therefore, by Lemma~\ref{lem:generalized-independence}
          (Generalized Independence), we have that
          $\config{U_S(S)}{e_{b_1}} \parstepsto
          \config{U_S(S_b)}{e_{b_2}}$.  Hence
          $\config{\extS{S}{l}{\bot}{\frozenfalse}}{e_{b_1}}
          \parstepsto
          \config{\extS{S_b}{l}{\bot}{\frozenfalse}}{e_{b_2}}$.  By
                 {\sc E-Eval-Ctxt} it follows that
                 $\config{\extS{S}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{e_{b_1}}}
                 \parstepsto
                 \config{\extS{S_b}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{e_{b_2}}}$,
                 which, since $S_b =
                 \extS{S}{l'}{\bot}{\frozenfalse}$, is what we were
                 required to show.  The argument for the second is
                 symmetrical.

        \item If $l = l'$:

          In this case, observe that we do \emph{not} want the
          expression in the final configuration to be
          $\evalctxt{E'_a}{e_{a_2}}$ (nor its equivalent,
          $\evalctxt{E'_b}{e_{b_2}}$).  The reason for this is that
          $\evalctxt{E'_a}{e_{a_2}}$ contains both occurrences of $l$.
          Rather, we want both configurations to step to a
          configuration in which exactly one occurrence of $l$ has
          been renamed to a fresh location $l''$.

          Let $l''$ be a location such that $l'' \notin \dom{S}$ and
          $l'' \neq l$ (and hence $l'' \neq l'$, as well).  Then
          choose $S' =
          \extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}$,
          $i = 1$, $j = 1$, and $\pi = \setof{(l, l'')}$.

          Either
          $\config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_a}{\pi(e_{a_2})}}$
          or
          $\config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{\pi(e_{b_2})}}$
          would work as a final configuration; we choose
          $\config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{\pi(e_{b_2})}}$.

          We have to show that:
          \begin{itemize}
          \item
            $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
            \config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{\pi(e_{b_2})}}$,
            and
          \item
            $\pi(\config{S_b}{\evalctxt{E'_a}{e_{a_1}}}) \ctxstepsto
            \config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{\pi(e_{b_2})}}$.
          \end{itemize}

          For the first of these, since $\config{S}{e_{b_1}}
          \parstepsto \config{S_b}{e_{b_2}}$, we have by
          Lemma~\ref{lem:permutability} (Permutability) that
          $\pi(\config{S}{e_{b_1}}) \parstepsto
          \pi(\config{S_b}{e_{b_2}})$.  Since $\pi = \setof{(l,
            l'')}$, but $l \notin S$ (from the side condition on {\sc
            E-New}), we have that $\pi(\config{S}{e_{b_1}}) =
          \config{S}{e_{b_1}}$. Since $\config{S_b}{e_{b_2}} =
          \config{\extS{S}{l'}{\bot}{\frozenfalse}}{l'}$, and $l = l'$, we have
          that $\pi(\config{S_b}{e_{b_2}}) =
          \config{\extS{S}{l''}{\bot}{\frozenfalse}}{\pi(e_{b_2})}$.  Hence
          $\config{S}{e_{b_1}} \parstepsto
          \config{\extS{S}{l''}{\bot}{\frozenfalse}}{\pi(e_{b_2})}$.

          Let $U_S$ be the store update operation that acts as the
          identity on the contents of all existing locations, and adds
          the binding $\storebinding{l}{\bot}{\frozenfalse}$ if no
          binding for $l$ exists.  Note that:
          \begin{itemize}
          \item $U_S$ is non-conflicting with $\config{S}{e_{b_1}}
            \parstepsto
            \config{\extS{S}{l''}{\bot}{\frozenfalse}}{\pi(e_{b_2})}$,
            since the only location allocated during the transition is
            $l''$;
          \item $U_S(\extS{S}{l''}{\bot}{\frozenfalse}) \neq \topS$,
            since $U_S(\extS{S}{l''}{\bot}{\frozenfalse}) =
            \extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}$
            and we know $S \neq \topS$ and the addition of new
            bindings $\storebinding{l}{\bot}{\frozenfalse}$ and
            $\storebinding{l''}{\bot}{\frozenfalse}$ cannot cause it
            to become $\topS$; and
          \item $U_S$ is freeze-safe with $\config{S}{e_{b_1}}
            \parstepsto
            \config{\extS{S}{l''}{\bot}{\frozenfalse}}{\pi(e_{b_2})}$,
            since $l'' \notin \dom{S}$, so there are no locations
            whose contents differ in status between $S$ and
            $\extS{S}{l''}{\bot}{\frozenfalse}$.
          \end{itemize}

          Therefore, by Lemma~\ref{lem:generalized-independence}
          (Generalized Independence), we have that
          $\config{U_S(S)}{e_{b_1}} \parstepsto
          \config{U_S(\extS{S}{l''}{\bot}{\frozenfalse})}{\pi(e_{b_2})}$.
          Hence $\config{\extS{S}{l}{\bot}{\frozenfalse}}{e_{b_1}}
          \parstepsto
          \config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\pi(e_{b_2})}$.
          By {\sc E-Eval-Ctxt} it follows that
          $\config{\extS{S}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{e_{b_1}}}
          \parstepsto
          \config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{\pi(e_{b_2})}}$,
          which, since $\extS{S}{l}{\bot}{\frozenfalse} = S_a$, is
          what we were required to show.

          For the second, observe that since $S_b =
          \extS{S}{l}{\bot}{\frozenfalse}$, we have that $\pi(S_b) =
          \extS{S}{l''}{\bot}{\frozenfalse}$.  Also, since $l$ does not occur in
          $e_{a_1}$, we have that $\pi(\evalctxt{E'_a}{e_{a_1}}) =
          \evalctxt{(\pi(E'_a))}{e_{a_1}}$.  Hence we have to show that

          $\config{\extS{S}{l''}{\bot}{\frozenfalse}}{\evalctxt{(\pi(E'_a))}{e_{a_1}}}
          \ctxstepsto
          \config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{\pi(e_{b_2})}}$.

          Let $U_S$ be the store update operation that acts as the
          identity on the contents of all existing locations, and adds
          the binding $\storebinding{l''}{\bot}{\frozenfalse}$ if no
          binding for $l''$ exists.  Note that:
          \begin{itemize}
          \item $U_S$ is non-conflicting with $\config{S}{e_{a_1}}
            \parstepsto \config{S_a}{e_{a_2}}$, since the only
            location allocated during the transition is $l$;
          \item $U_S(S_a) \neq \topS$, since $U_S(S_a) =
            \extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}$
            and we know $S \neq \topS$ and the addition of new
            bindings $\storebinding{l}{\bot}{\frozenfalse}$ and
            $\storebinding{l''}{\bot}{\frozenfalse}$ cannot cause it
            to become $\topS$; and
          \item $U_S$ is freeze-safe with $\config{S}{e_{a_1}}
            \parstepsto \config{S_a}{e_{a_2}}$, since $S_a =
            \extS{S}{l}{\bot}{\frozenfalse}$ and $l \notin \dom{S}$,
            so there are no locations whose contents differ in status
            between $S$ and $S_a$.
          \end{itemize}

          Therefore, by Lemma~\ref{lem:generalized-independence}
          (Generalized Independence), we have that
          $\config{U_S(S)}{e_{a_1}} \parstepsto
          \config{U_S(S_a)}{e_{a_2}}$.  Hence
          $\config{\extS{S}{l''}{\bot}{\frozenfalse}}{e_{a_1}}
          \parstepsto
          \config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{e_{a_2}}$.
          By {\sc E-Eval-Ctxt} it follows that
          $\config{\extS{S}{l''}{\bot}{\frozenfalse}}{\evalctxt{(\pi(E'_a))}{e_{a_1}}}
          \ctxstepsto
          \config{\extS{\extS{S}{l''}{\bot}{\frozenfalse}}{l}{\bot}{\frozenfalse}}{\evalctxt{(\pi(E'_a))}{e_{a_2}}}$,
          which completes the case since
          $\evalctxt{E'_b}{\pi(e_{b_2})} =
          \evalctxt{(\pi(E'_a))}{e_{a_2}}$.

          \lk{This is really sketchy -- I should really explain why
            $\evalctxt{E'_b}{\pi(e_{b_2})} =
            \evalctxt{(\pi(E'_a))}{e_{a_2}}$.}

      \end{itemize}

    \item \label{slqc-new-put}Case {\sc E-Put}: We have $S_a =
      \extS{S}{l}{\bot}{\frozenfalse}$ and $S_b =
      \extSRaw{S}{l'}{u_{p_i}(p_1)}$.

      We have to show that:
      \begin{itemize}
      \item $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \config{\extS{S_b}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{e_{b_2}}}$,
        and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
        \config{\extS{S_b}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_a}{e_{a_2}}}$.
      \end{itemize}

      For the first of these, consider that $S_a =
      \extS{S}{l}{\bot}{\frozenfalse} = U_S(S)$, where $U_S$ is the
      store update operation that acts as the identity on the contents
      of all existing locations, and adds the binding
      $\storebinding{l}{\bot}{\frozenfalse}$ if no binding for $l$
      exists.  Note that:
      \begin{itemize}
      \item $U_S$ is non-conflicting with $\config{S}{e_{b_1}}
        \parstepsto \config{S_b}{e_{b_2}}$, since no locations are
        allocated during the transition;
      \item $U_S(S_b) \neq \topS$, since $U_S(S_b) =
        U_S(\extS{S_b}{l}{\bot}{\frozenfalse})$, \TODO{this looks
          wrong} and we know $S_b \neq \topS$ and the addition of a
        new binding $\storebinding{l}{\bot}{\frozenfalse}$ cannot
        cause it to become $\topS$; and
      \item $U_S$ is freeze-safe with $\config{S}{e_{b_1}} \parstepsto
        \config{S_b}{e_{b_2}}$, since $S_b =
        \extSRaw{S}{l'}{u_{p_i}(p_1)}$ and $u_{p_i}$ does not alter
        the status of $p_1$.  (By
        Definition~\ref{def:set-of-state-update-operations}, $u_{p_i}$
        can only change the status bit of a location if its contents
        are $\state{d}{\frozentrue}$ and $u_i(d) \neq d$, in which
        case $u_{p_i}$ changes the contents of the location to
        $\state{\top}{\frozenfalse}$; however, that cannot be the case
        here since then $S_b$ would be $\topS$, contradicting our
        assumption that $\conf_b \neq \error$.)
      \end{itemize}

      Therefore, by Lemma~\ref{lem:generalized-independence}
      (Generalized Independence), we have that
      $\config{U_S(S)}{e_{b_1}} \parstepsto
      \config{U_S(S_b)}{e_{b_2}}$.  Hence
      $\config{\extS{S}{l}{\bot}{\frozenfalse}}{e_{b_1}} \parstepsto
      \config{\extS{S_b}{l}{\bot}{\frozenfalse}}{e_{b_2}}$.  By {\sc
        E-Eval-Ctxt}, it follows that
      $\config{\extS{S}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{e_{b_1}}}
      \ctxstepsto
      \config{\extS{S_b}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{e_{b_2}}}$,
      which, since $S_a = \extS{S}{l}{\bot}{\frozenfalse}$, is what we
      were required to show.

      For the second, let $U_S$ be the store update operation that
      applies $u_{p_i}$ to the contents of $l'$ if it exists, and adds
      a binding $\storebindingRaw{l'}{u_{p_i}(p_1)}$ if no binding for
      $l'$ exists.

      Consider that $S_b = U_S(S)$, and
      $\extS{S_b}{l}{\bot}{\frozenfalse} =
      \extSRaw{S_a}{l'}{u_{p_i}(p_1)} = U_S(S_a)$.  Note that:
      \begin{itemize}
      \item $U_S$ is non-conflicting with $\config{S}{e_{a_1}}
        \parstepsto \config{S_a}{e_{a_2}}$, since the only location
        allocated during the transition is $l$;
      \item $U_S(S_a) \neq \topS$, since $U_S(S_a) =
        \extSRaw{\extS{S}{l}{\bot}{\frozenfalse}}{l'}{u_{p_i}(p_1)}$
        and we know $S \neq \topS$ and the addition of new bindings
        $\storebinding{l}{\bot}{\frozenfalse}$ and
        $\storebindingRaw{l'}{u_{p_i}(p_1)}$ cannot cause it to become
        $\topS$ (since if $u_{p_i}(p_1) = \topp$,
        $\config{S}{e_{b_1}}$ would not have been able to step by {\sc
          E-Put}); and
      \item $U_S$ is freeze-safe with $\config{S}{e_{a_1}} \parstepsto
        \config{S_a}{e_{a_2}}$, since $S_a =
        \extS{S}{l}{\bot}{\frozenfalse}$ and $l \notin \dom{S}$, so
        there are no locations whose contents differ in status between
        $S$ and $S_a$.
      \end{itemize}

      Therefore, by Lemma~\ref{lem:generalized-independence}
      (Generalized Independence), we have that
      $\config{U_S(S)}{e_{a_1}} \parstepsto
      \config{U_S(S_a)}{e_{a_2}}$.  Hence $\config{S_b}{e_{a_1}}
      \parstepsto
      \config{\extS{S_b}{l}{\bot}{\frozenfalse}}{e_{a_2}}$.  By {\sc
        E-Eval-Ctxt}, it follows that
      $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
      \config{\extS{S_b}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_a}{e_{a_2}}}$,
      as we were required to show.

    \item \label{slqc-new-put-err}Case {\sc E-Put-Err}: We have $S_a =
      \extS{S}{l}{\bot}{\frozenfalse}$ and $\config{S_b}{e_{b_2}} =
      \error$, and so we choose $\conf_c = \error$, $i = 1$, $j = 0$,
      and $\pi = \id$.  We have to show that:
      \begin{itemize}
      \item $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \error$, and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} = \error$.
      \end{itemize}

      The second of these is immediately true because since
      $\config{S_b}{e_{b_2}} = \error$, $S_b = \topS$, and so
      $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}}$ is equal to $\error$ as
      well.  For the first, observe that since $\config{S}{e_{a_1}}
      \parstepsto \config{S_a}{e_{a_2}}$, we have by
      Lemma~\ref{lem:monotonicity} (Monotonicity) that
      $\leqstore{S}{S_a}$.  Therefore, since $\config{S}{e_{b_1}}
      \parstepsto \error$, we have by
      Lemma~\ref{lem:error-preservation} (Error Preservation) that
      $\config{S_a}{e_{b_1}} \parstepsto \error$.  Since $\error$ is
      equal to $\config{\topS}{e}$ for all expressions $e$,
      $\config{S_a}{e_{b_1}} \parstepsto \config{\topS}{e}$ for all
      $e$.  Therefore, by {\sc E-Eval-Ctxt},
      $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
      \config{\topS}{\evalctxt{E'_b}{e}}$ for all $e$.  Since
      $\config{\topS}{\evalctxt{E'_b}{e}}$ is equal to $\error$, we
      have that $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
      \error$, as we were required to show.

    \item \label{slqc-new-get}Case {\sc E-Get}: Similar to
      case~\ref{slqc-new-beta}, since $S_a =
      \extS{S}{l}{\bot}{\frozenfalse}$ and $S_b = S$.
    \item \label{slqc-new-freeze-init}Case {\sc E-Freeze-Init}:
      Similar to case~\ref{slqc-new-beta}, since $S_a =
      \extS{S}{l}{\bot}{\frozenfalse}$ and $S_b = S$.
    \item \label{slqc-new-spawn-handler}Case {\sc E-Spawn-Handler}:
      Similar to case~\ref{slqc-new-beta}, since $S_a =
      \extS{S}{l}{\bot}{\frozenfalse}$ and $S_b = S$.
    \item \label{slqc-new-freeze-final}Case {\sc E-Freeze-Final}: We
      have $S_a = \extS{S}{l}{\bot}{\frozenfalse}$ and $S_b =
      \extS{S}{l'}{d_1}{\frozentrue}$.

      Choose $S' =
      \extS{\extS{S}{l}{\bot}{\frozenfalse}}{l'}{d_1}{\frozentrue}$,
      $i = i$, $j = 1$, and $\pi = \id$.

      We have to show that:
      \begin{itemize}
      \item
        $\config{\extS{S}{l}{\bot}{\frozenfalse}}{\evalctxt{E'_b}{e_{b_1}}}
        \ctxstepsto
        \config{\extS{\extS{S}{l}{\bot}{\frozenfalse}}{l'}{d_1}{\frozentrue}}{\evalctxt{E'_b}{e_{b_2}}}$,
        and
      \item
        $\config{\extS{S}{l'}{d_1}{\frozentrue}}{\evalctxt{E'_a}{e_{a_1}}}
        \ctxstepsto
        \config{\extS{\extS{S}{l'}{d_1}{\frozentrue}}{l'}{d_1}{\frozentrue}}{\evalctxt{E'_a}{e_{a_2}}}$.
      \end{itemize}

      For the first of these, consider that
      $\extS{S}{l}{\bot}{\frozenfalse} = U_S(S)$, where $U_S$ is the
      store update operation that acts as the identity on the contents
      of all existing locations, and adds the binding
      $\storebinding{l}{\bot}{\frozenfalse}$ if no binding for $l$
      exists.  Note that:
      \begin{itemize}
        \item $U_S$ is non-conflicting with $\config{S}{e_{b_1}}
          \parstepsto \config{S_b}{e_{b_2}}$, since no locations are
          allocated during the transition;
        \item $U_S(S_b) \neq \topS$, since $U_S(S_b) =
          \extS{S_b}{l}{\bot}{\frozenfalse}$, and we know $S_b \neq
          \topS$ and the addition of a new binding
          $\storebinding{l}{\bot}{\frozenfalse}$ cannot cause it to
          become $\topS$; and
        \item $U_S$ is freeze-safe with $\config{S}{e_{b_1}}
          \parstepsto \config{S_b}{e_{b_2}}$, since $S_b =
          \extS{S}{l'}{d_1}{\frozentrue}$ and so the only location
          that can change in status between $S$ and $S_b$ is $l'$, and
          $U_S$ acts as the identity on $l$.
      \end{itemize}

      \TODO{}

    \item \label{slqc-new-freeze-simple}Case {\sc E-Freeze-Simple}:
      Similar to case~\ref{slqc-new-freeze-final}, since $S_a =
      \extS{S}{l}{\bot}{\frozenfalse}$ and $S_b =
      \extS{S}{l'}{d_1}{\frozentrue}$.

    \end{enumerate}
  \item Case {\sc E-Put}: We have $S_a =
    \extSRaw{S}{l}{u_{p_i}(p_1)}$.

    We proceed by case analysis on the rule by which
    $\config{S}{e_{b_1}}$ steps to $\config{S_b}{e_{b_2}}$.  Since the
    only way an $\error$ configuration can arise is by the {\sc
      E-Put-Err} rule, we can assume in all other cases that $\conf_b
    \neq \error$.
    \begin{enumerate}
    \item \label{slqc-put-beta}Case {\sc E-Beta}: By symmetry with case~\ref{slqc-beta-put}.
    \item \label{slqc-put-new}Case {\sc E-New}: By symmetry with case~\ref{slqc-new-put}.
    \item \label{slqc-put-put}Case {\sc E-Put}: We have $S_a =
      \extSRaw{S}{l}{u_{p_i}(p_1)}$ and $S_b =
      \extSRaw{S}{l'}{u_{p_j}(p'_1)}$, where $p'_1 = S(l')$.

      Now consider whether $l = l'$:
      \begin{itemize}
        \item If $l \neq l'$:

          Choose $S' =
          \extSRaw{\extSRaw{S}{l'}{u_{p_j}(p'_1)}}{l}{u_{p_i}(p_1)}$,
          $i = 1$, $j = 1$, and $\pi = \id$.

          We have to show that:
          \begin{itemize}
          \item
            $\config{\extSRaw{S}{l}{u_{p_i}(p_1)}}{\evalctxt{E'_b}{e_{b_1}}}
            \ctxstepsto
            \config{\extSRaw{\extSRaw{S}{l'}{u_{p_j}(p'_1)}}{l}{u_{p_i}(p_1)}}{\evalctxt{E'_b}{e_{b_2}}}$,
            and
          \item
            $\config{\extSRaw{S}{l'}{u_{p_j}(p'_1)}}{\evalctxt{E'_a}{e_{a_1}}}
            \ctxstepsto
            \config{\extSRaw{\extSRaw{S}{l'}{u_{p_j}(p'_1)}}{l}{u_{p_i}(p_1)}}{\evalctxt{E'_a}{e_{a_2}}}$.
          \end{itemize}
          \TODO{}

        \item If $l = l'$:

          Note that since $l = l'$, $p_1 = p'_1$ as well.

          Choose $S' = \extSRaw{S}{l}{u_{p_i}(u_{p_j}(p_1))}$, $i =
          1$, $j = 1$, and $\pi = \id$.

          We have to show that:
          \begin{itemize}
          \item
            $\config{\extSRaw{S}{l}{u_{p_i}(p_1)}}{\evalctxt{E'_b}{e_{b_1}}}
            \ctxstepsto
            \config{\extSRaw{S}{l}{u_{p_i}(u_{p_j}(p_1))}}{\evalctxt{E'_b}{e_{b_2}}}$,
            and
          \item
            $\config{\extSRaw{S}{l}{u_{p_j}(p_1)}}{\evalctxt{E'_a}{e_{a_1}}}
            \ctxstepsto
            \config{\extSRaw{S}{l}{u_{p_i}(u_{p_j}(p_1))}}{\evalctxt{E'_a}{e_{a_2}}}$.
          \end{itemize}
          \TODO{}

      \end{itemize}

    \item \label{slqc-put-put-err}Case {\sc E-Put-Err}: We have $S_a =
      \extSRaw{S}{l}{u_{p_i}(p_1)}$ and $\config{S_b}{e_{b_2}} =
      \error$, and so we choose $\conf_c = \error$, $i = 1$, $j = 0$,
      and $\pi = \id$.  We have to show that:
      \begin{itemize}
      \item $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \error$, and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} = \error$.
      \end{itemize}

      The second of these is immediately true because since
      $\config{S_b}{e_{b_2}} = \error$, $S_b = \topS$, and so
      $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}}$ is equal to $\error$ as
      well.  For the first, observe that since $\config{S}{e_{a_1}}
      \parstepsto \config{S_a}{e_{a_2}}$, we have by
      Lemma~\ref{lem:monotonicity} (Monotonicity) that
      $\leqstore{S}{S_a}$.  Therefore, since $\config{S}{e_{b_1}}
      \parstepsto \error$, we have by
      Lemma~\ref{lem:error-preservation} (Error Preservation) that
      $\config{S_a}{e_{b_1}} \parstepsto \error$.  Since $\error$ is
      equal to $\config{\topS}{e}$ for all expressions $e$,
      $\config{S_a}{e_{b_1}} \parstepsto \config{\topS}{e}$ for all
      $e$.  Therefore, by {\sc E-Eval-Ctxt},
      $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
      \config{\topS}{\evalctxt{E'_b}{e}}$ for all $e$.  Since
      $\config{\topS}{\evalctxt{E'_b}{e}}$ is equal to $\error$, we
      have that $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
      \error$, as we were required to show.

    \item \label{slqc-put-get}Case {\sc E-Get}: Similar to
      case~\ref{slqc-put-beta}, since $S_a =
      \extSRaw{S}{l}{u_{p_i}(p_1)}$ and $S_b = S$.
    \item \label{slqc-put-freeze-init}Case {\sc E-Freeze-Init}:
      Similar to case~\ref{slqc-put-beta}, since $S_a =
      \extSRaw{S}{l}{u_{p_i}(p_1)}$ and $S_b = S$.
    \item \label{slqc-put-spawn-handler}Case {\sc E-Spawn-Handler}:
      Similar to case~\ref{slqc-put-beta}, since $S_a =
      \extSRaw{S}{l}{u_{p_i}(p_1)}$ and $S_b = S$.
    \item \label{slqc-put-freeze-final}Case {\sc E-Freeze-Final}: We
      have $S_a = \extSRaw{S}{l}{u_{p_i}(p_1)}$ and $S_b =
      \extS{S}{l'}{d_1}{\frozentrue}$.

      Now consider whether $l = l'$:
      \begin{itemize}
        \item If $l \neq l'$:

          \TODO{}

        \item If $l = l'$:

          Note that since $l = l'$, $p_1 = \state{d_1}{\frozentrue}$.

          \TODO{}
      \end{itemize}

    \item \label{slqc-put-freeze-simple}Case {\sc E-Freeze-Simple}:
      Similar to case~\ref{slqc-put-freeze-final}, since $S_a =
      \extSRaw{S}{l}{u_{p_i}(p_1)}$ and $S_b =
      \extS{S}{l'}{d_1}{\frozentrue}$.

    \end{enumerate}
  \item Case {\sc E-Put-Err}: We have $\config{S_a}{e_{a_2}} =
    \error$.

    We proceed by case analysis on the rule by which
    $\config{S}{e_{b_1}}$ steps to $\config{S_b}{e_{b_2}}$.  Since the
    only way an $\error$ configuration can arise is by the {\sc
      E-Put-Err} rule, we can assume in all other cases that $\conf_b
    \neq \error$.
    \begin{enumerate}
    \item \label{slqc-put-err-beta}Case {\sc E-Beta}: By symmetry with case~\ref{slqc-beta-put-err}.
    \item \label{slqc-put-err-new}Case {\sc E-New}: By symmetry with case~\ref{slqc-new-put-err}.
    \item \label{slqc-put-err-put}Case {\sc E-Put}: By symmetry with case~\ref{slqc-put-put-err}.
    \item \label{slqc-put-err-put-err}Case {\sc E-Put-Err}: We have
      $\config{S_a}{e_{a_2}} = \error$ and $\config{S_b}{e_{b_2}} =
      \error$, and so we choose $\conf_c = \error$, $i = 0$, $j = 0$,
      and $\pi = \id$.  We have to show that:
      \begin{itemize}
      \item $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} = \error$, and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} = \error$.
      \end{itemize}

      Since $\config{S_a}{e_{a_2}} = \error$, $S_a = \topS$, and since
      $\config{S_b}{e_{b_2}} = \error$, $S_b = \topS$, so both of the
      above follow immediately.

    \item \label{slqc-put-err-get}Case {\sc E-Get}: Similar to
      case~\ref{slqc-put-err-beta}, since $\config{S_a}{e_{a_2}} =
      \error$ and $S_b = S$.
    \item \label{slqc-put-err-freeze-init}Case {\sc E-Freeze-Init}:
      Similar to case~\ref{slqc-put-err-beta}, since
      $\config{S_a}{e_{a_2}} = \error$ and $S_b = S$.
    \item \label{slqc-put-err-spawn-handler}Case {\sc
      E-Spawn-Handler}: Similar to case~\ref{slqc-put-err-beta}, since
      $\config{S_a}{e_{a_2}} = \error$ and $S_b = S$.
    \item \label{slqc-put-err-freeze-final}Case {\sc E-Freeze-Final}:
      We have $\config{S_a}{e_{a_2}} = \error$ and $S_b =
      \extS{S}{l}{d_1}{\frozentrue}$, and so we choose $\conf_c =
      \error$, $i = 0$, $j = 1$, and $\pi = \id$.  We have to show
      that:
      \begin{itemize}
      \item $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}} = \error$,
        and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto \error$.
      \end{itemize}

      The first of these is immediately true because since
      $\config{S_a}{e_{a_2}} = \error$, $S_a = \topS$, and so
      $\config{S_a}{\evalctxt{E'_b}{e_{b_1}}}$ is equal to $\error$ as
      well.  For the second, observe that since $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$, we have by
      Lemma~\ref{lem:monotonicity} (Monotonicity) that
      $\leqstore{S}{S_b}$.  Therefore, since $\config{S}{e_{a_1}}
      \parstepsto \error$, we have by
      Lemma~\ref{lem:error-preservation} that $\config{S_b}{e_{a_1}}
      \parstepsto \error$.  Since $\error$ is equal to
      $\config{\topS}{e}$ for all expressions $e$,
      $\config{S_b}{e_{a_1}} \parstepsto \config{\topS}{e}$ for all
      $e$.  Therefore, by {\sc E-Eval-Ctxt},
      $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
      \config{\topS}{\evalctxt{E'_a}{e}}$ for all $e$.  Since
      $\config{\topS}{\evalctxt{E'_a}{e}}$ is equal to $\error$, we
      have that $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
      \error$, as we were required to show.

    \item \label{slqc-put-err-freeze-simple}Case {\sc
      E-Freeze-Simple}: Similar to
      case~\ref{slqc-put-err-freeze-final}, since $S_b =
      \extS{S}{l}{d_1}{\frozentrue}$.

    \end{enumerate}
  \item Case {\sc E-Get}: We have $S_a = S$.

    We proceed by case analysis on the rule by which
    $\config{S}{e_{b_1}}$ steps to $\config{S_b}{e_{b_2}}$.  Since the
    only way an $\error$ configuration can arise is by the {\sc
      E-Put-Err} rule, we can assume in all other cases that $\conf_b
    \neq \error$.
    \begin{enumerate}
    \item \label{slqc-get-beta}Case {\sc E-Beta}: By symmetry with case~\ref{slqc-beta-get}.
    \item \label{slqc-get-new}Case {\sc E-New}: By symmetry with case~\ref{slqc-new-get}.
    \item \label{slqc-get-put}Case {\sc E-Put}: By symmetry with case~\ref{slqc-put-get}.
    \item \label{slqc-get-put-err}Case {\sc E-Put-Err}: By symmetry with case~\ref{slqc-put-err-get}.
    \item \label{slqc-get-get}Case {\sc E-Get}: Similar to
      case~\ref{slqc-get-beta}, since $S_a = S$ and $S_b = S$.
    \item \label{slqc-get-freeze-init}Case {\sc E-Freeze-Init}:
      Similar to case~\ref{slqc-get-beta}, since $S_a = S$ and $S_b = S$.
    \item \label{slqc-get-spawn-handler}Case {\sc E-Spawn-Handler}:
      Similar to case~\ref{slqc-get-beta}, since $S_a = S$ and $S_b = S$.
    \item \label{slqc-get-freeze-final}Case {\sc E-Freeze-Final}: We
      have $S_a = S$ and $S_b = \extS{S}{l}{d_1}{\frozentrue}$.

      Choose $S' = S_b$, $i = 1$, $j = 1$, and $\pi = \id$.

      We have to show that:
      \begin{itemize}
      \item $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_b}{e_{b_2}}}$, and
      \item $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$.
      \end{itemize}

      The first of these follows immediately from $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$ and {\sc E-Eval-Ctxt}.  For
      the second, \TODO{}.

    \item \label{slqc-get-freeze-simple}Case {\sc E-Freeze-Simple}:
      Similar to case~\ref{slqc-get-freeze-final}, since $S_a = S$ and $S_b =
      \extS{S}{l}{d_1}{\frozentrue}$.
    \end{enumerate}

  \item Case {\sc E-Freeze-Init}: We have $S_a = S$.

    We proceed by case analysis on the rule by which
    $\config{S}{e_{b_1}}$ steps to $\config{S_b}{e_{b_2}}$.  Since the
    only way an $\error$ configuration can arise is by the {\sc
      E-Put-Err} rule, we can assume in all other cases that $\conf_b
    \neq \error$.
    \begin{enumerate}
    \item \label{slqc-freeze-init-beta}Case {\sc E-Beta}: By symmetry with case~\ref{slqc-beta-freeze-init}.
    \item \label{slqc-freeze-init-new}Case {\sc E-New}: By symmetry with case~\ref{slqc-new-freeze-init}.
    \item \label{slqc-freeze-init-put}Case {\sc E-Put}: By symmetry with case~\ref{slqc-put-freeze-init}.
    \item \label{slqc-freeze-init-put-err}Case {\sc E-Put-Err}: By symmetry with case~\ref{slqc-put-err-freeze-init}.
    \item \label{slqc-freeze-init-get}Case {\sc E-Get}: By symmetry with case~\ref{slqc-get-freeze-init}.
    \item \label{slqc-freeze-init-freeze-init}Case {\sc
      E-Freeze-Init}: Similar to case~\ref{slqc-freeze-init-beta},
      since $S_a = S$ and $S_b = S$.
    \item \label{slqc-freeze-init-spawn-handler}Case {\sc
      E-Spawn-Handler}: Similar to case~\ref{slqc-freeze-init-beta},
      since $S_a = S$ and $S_b = S$.
    \item \label{slqc-freeze-init-freeze-final}Case {\sc
      E-Freeze-Final}: We have $S_a = S$ and $S_b =
      \extS{S}{l}{d_1}{\frozentrue}$.

      Choose $S' = S_b$, $i = 1$, $j = 1$, and $\pi = \id$.

      We have to show that:
      \begin{itemize}
      \item $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_b}{e_{b_2}}}$, and
      \item
        $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$.
      \end{itemize}

      The first of these follows immediately from $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$ and {\sc E-Eval-Ctxt}.  For
      the second, \TODO{}.

    \item \label{slqc-freeze-init-freeze-simple}Case {\sc
      E-Freeze-Simple}: Similar to
      case~\ref{slqc-freeze-init-freeze-final}, since $S_a = S$ and
      $S_b = \extS{S}{l}{d_1}{\frozentrue}$.
    \end{enumerate}

  \item Case {\sc E-Spawn-Handler}: We have $S_a = S$.

    We proceed by case analysis on the rule by which
    $\config{S}{e_{b_1}}$ steps to $\config{S_b}{e_{b_2}}$.  Since the
    only way an $\error$ configuration can arise is by the {\sc
      E-Put-Err} rule, we can assume in all other cases that $\conf_b
    \neq \error$.
    \begin{enumerate}
    \item \label{slqc-spawn-handler-beta}Case {\sc E-Beta}: By symmetry with case~\ref{slqc-beta-spawn-handler}.
    \item \label{slqc-spawn-handler-new}Case {\sc E-New}: By symmetry with case~\ref{slqc-new-spawn-handler}.
    \item \label{slqc-spawn-handler-put}Case {\sc E-Put}: By symmetry with case~\ref{slqc-put-spawn-handler}.
    \item \label{slqc-spawn-handler-put-err}Case {\sc E-Put-Err}: By symmetry with case~\ref{slqc-put-err-spawn-handler}.
    \item \label{slqc-spawn-handler-get}Case {\sc E-Get}: By symmetry with case~\ref{slqc-get-spawn-handler}.
    \item \label{slqc-spawn-handler-freeze-init}Case {\sc E-Freeze-Init}: By symmetry with case~\ref{slqc-freeze-init-spawn-handler}.
    \item \label{slqc-spawn-handler-spawn-handler}Case {\sc
      E-Spawn-Handler}: Similar to case~\ref{slqc-spawn-handler-beta},
      since $S_a = S$ and $S_b = S$.
    \item \label{slqc-spawn-handler-freeze-final}Case {\sc
      E-Freeze-Final}: We have $S_a = S$ and $S_b =
      \extS{S}{l}{d_1}{\frozentrue}$.

      Choose $S' = S_b$, $i = 1$, $j = 1$, and $\pi = \id$.

      We have to show that:
      \begin{itemize}
      \item $\config{S}{\evalctxt{E'_b}{e_{b_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_b}{e_{b_2}}}$, and
      \item $\config{S_b}{\evalctxt{E'_a}{e_{a_1}}} \ctxstepsto
        \config{S_b}{\evalctxt{E'_a}{e_{a_2}}}$.
      \end{itemize}

      The first of these follows immediately from $\config{S}{e_{b_1}}
      \parstepsto \config{S_b}{e_{b_2}}$ and {\sc E-Eval-Ctxt}.  For
      the second, \TODO{}.

    \item \label{slqc-spawn-handler-freeze-simple}Case {\sc
      E-Freeze-Simple}: Similar to
      case~\ref{slqc-spawn-handler-freeze-final}, since $S_a = S$ and
      $S_b = \extS{S}{l}{d_1}{\frozentrue}$.
    \end{enumerate}

  \item Case {\sc E-Freeze-Final}: We have $S_a =
    \extS{S}{l}{d_1}{\frozentrue}$.

    We proceed by case analysis on the rule by which
    $\config{S}{e_{b_1}}$ steps to $\config{S_b}{e_{b_2}}$.  Since the
    only way an $\error$ configuration can arise is by the {\sc
      E-Put-Err} rule, we can assume in all other cases that $\conf_b
    \neq \error$.
    \begin{enumerate}
    \item \label{slqc-freeze-final-beta}Case {\sc E-Beta}: By symmetry with case~\ref{slqc-beta-freeze-final}.
    \item \label{slqc-freeze-final-new}Case {\sc E-New}: By symmetry with case~\ref{slqc-new-freeze-final}.
    \item \label{slqc-freeze-final-put}Case {\sc E-Put}: By symmetry with case~\ref{slqc-put-freeze-final}.
    \item \label{slqc-freeze-final-put-err}Case {\sc E-Put-Err}: By symmetry with case~\ref{slqc-put-err-freeze-final}.
    \item \label{slqc-freeze-final-get}Case {\sc E-Get}: By symmetry with case~\ref{slqc-get-freeze-final}.
    \item \label{slqc-freeze-final-freeze-init}Case {\sc E-Freeze-Init}: By symmetry with case~\ref{slqc-freeze-init-freeze-final}.
    \item \label{slqc-freeze-final-spawn-handler}Case {\sc E-Spawn-Handler}: By symmetry with case~\ref{slqc-spawn-handler-freeze-final}.
    \item \label{slqc-freeze-final-freeze-final}Case {\sc
      E-Freeze-Final}: We have $S_a = \extS{S}{l}{d_1}{\frozentrue}$
      and $S_b = \extS{S}{l'}{d'_1}{\frozentrue}$.

      Now consider whether $l = l'$:
      \begin{itemize}
        \item If $l \neq l'$:

          \TODO{}

        \item If $l = l'$:

          Note that since $l = l'$, $d_1 = d'_1$.

          \TODO{}
      \end{itemize}


    \item \label{slqc-freeze-final-freeze-simple}Case {\sc
      E-Freeze-Simple}: Similar to
      case~\ref{slqc-freeze-final-freeze-final}, since $S_a =
      \extS{S}{l}{d_1}{\frozentrue}$ and $S_b =
      \extS{S}{l'}{d'_1}{\frozentrue}$.
    \end{enumerate}

  \item Case {\sc E-Freeze-Simple}: We have $S_a =
    \extS{S}{l}{d_1}{\frozentrue}$.

    \begin{enumerate}
    \item \label{slqc-freeze-simple-beta}Case {\sc E-Beta}: By symmetry with case~\ref{slqc-beta-freeze-simple}.
    \item \label{slqc-freeze-simple-new}Case {\sc E-New}: By symmetry with case~\ref{slqc-new-freeze-simple}.
    \item \label{slqc-freeze-simple-put}Case {\sc E-Put}: By symmetry with case~\ref{slqc-put-freeze-simple}.
    \item \label{slqc-freeze-simple-put-err}Case {\sc E-Put-Err}: By symmetry with case~\ref{slqc-put-err-freeze-simple}.
    \item \label{slqc-freeze-simple-get}Case {\sc E-Get}: By symmetry with case~\ref{slqc-get-freeze-simple}.
    \item \label{slqc-freeze-simple-freeze-init}Case {\sc E-Freeze-Init}: By symmetry with case~\ref{slqc-freeze-init-freeze-simple}.
    \item \label{slqc-freeze-simple-spawn-handler}Case {\sc E-Spawn-Handler}: By symmetry with case~\ref{slqc-spawn-handler-freeze-simple}.
    \item \label{slqc-freeze-simple-freeze-final}Case {\sc E-Freeze-Final}: By symmetry with case~\ref{slqc-freeze-final-freeze-simple}.
    \item \label{slqc-freeze-simple-freeze-simple}Case {\sc
      E-Freeze-Simple}: Similar to
      case~\ref{slqc-freeze-simple-freeze-final}, since $S_a =
      \extS{S}{l}{d_1}{\frozentrue}$ and $S_b =
      \extS{S}{l'}{d'_1}{\frozentrue}$.
    \end{enumerate}

  \end{enumerate}
\end{proof}

