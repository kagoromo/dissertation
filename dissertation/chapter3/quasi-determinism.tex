\section{Proof of quasi-determinism for $\lambdaLVish$}\label{s:quasi-proof-of-quasi-determinism}

In this section, I give a proof of quasi-determinism for
$\lambdaLVish$ that formalizes the claim made earlier in this chapter:
that, for a given program, although some executions may raise
exceptions, all executions that produce a final result will produce
the same final result.

The quasi-determinism theorem I show says that if two executions
starting from a configuration $\conf$ terminate in configurations
$\conf'$ and $\conf''$, then either $\conf'$ and $\conf''$ are the
same configuration (up to a permutation on locations), or one of them
is $\error$.  As with the determinism proof for $\lambdaLVar$ that I
give in Section~\ref{s:lvars-proof}, quasi-determinism follows from a
series of supporting lemmas.  The basic structure of the proof follows
that of the $\lambdaLVar$ determinism proof closely.  Unlike for
$\lambdaLVar$, though, for $\lambdaLVish$ I do not need to prove a
Clash lemma (\eg, Lemma~\ref{lem:lvars-clash}) or an Error
Preservation lemma (\eg, Lemma~\ref{lem:lvars-error-preservation}).
Those lemmas are unnecessary here because quasi-determinism is a
weaker property than determinism.

\subsection{Permutations and permutability}\label{subsection:quasi-permutations}

As with $\lambdaLVar$, the $\lambdaLVish$ is nondeterministic with
respect to the names of locations it allocates.  We therefore prove
quasi-determinism up to a permutation on locations.  We can reuse the
definition of a permutation verbatim from
Section~\ref{subsection:lvars-permutations}:

\DefPermutation

We can then lift $\pi$ to apply expressions, stores, and
configurations.  Because expressions and stores are defined slightly
differently in $\lambdaLVish$ than they are in $\lambdaLVar$, we must
update our definitions of permutation of a store and permutation of an
expression:

\DefPermutationExpression

\DefPermutationStore

And the definition of permutation of a configuration is as it was before:

\DefPermutationConfiguration

We can now prove a Permutability lemma for $\lambdaLVish$, which says
that a configuration $\conf$ can step to $\conf'$ exactly when
$\pi(\conf)$ can step to $\pi(\conf')$.

\LemPermutability
\begin{proof}
  Similar to the proof of Lemma~\ref{lem:lvars-permutability}
  (Permutability for $\lambdaLVar$); see
  Section~\ref{section:permutability-proof}.
\end{proof}

\lk{For now, not saying anything about internal determinism, because I
  don't know if we need it.}

\subsection{Locality}

Just as with the determinism proof for $\lambdaLVar$, proving
quasi-determinism for $\lambdaLVish$ will require us to handle
expressions that can decompose into redex and context in multiple
ways.  An expression $e$ such that $e = \evalctxt{E_1}{e_1} =
\evalctxt{E_2}{e_2}$ can step in two different ways by the {\sc
  E-Eval-Ctxt} rule: $\config{S}{\evalctxt{E_1}{e_1}} \ctxstepsto
\config{S_1}{\evalctxt{E_1}{e'_1}}$, and
$\config{S}{\evalctxt{E_2}{e_2}} \ctxstepsto
\config{S_2}{\evalctxt{E_2}{e'_2}}$.

The Locality lemma says that $\ctxstepsto$ acts ``locally'' in each of
these steps: when $e_1$ steps to $e'_1$ within its context, the
expression $e_2$ will be left alone, because it belongs to the
context.  Likewise, when $e_2$ steps to $e'_2$ within its context, the
expression $e_1$ will be left alone.  The statement of the Locality
lemma is the same as that of Lemma~\ref{lem:lvars-locality} (Locality
for $\lambdaLVar$), but the proof must account for the set of possible
evaluation contexts in $\lambdaLVish$ being different (and larger).

\LemLocality
\begin{proof}
  \TODO{Add short description here once the proof is done.} See
  Section~\ref{section:locality-proof}.
\end{proof}

\subsection{Monotonicity}\label{subsection:quasi-monotonicity}

The Monotonicity lemma says that, as evaluation proceeds according to
the $\parstepsto$ relation, the store can only grow with respect to
the $\leqstore{}{}$ ordering.

\LemMonotonicity
\begin{proof}
  Straightforward by cases on the rule of the reduction semantics by
  which $\config{S}{e}$ steps to $\config{S'}{e'}$. The interesting
  cases are for the {\sc E-New} and {\sc E-Put} rules.  See
  Section~\ref{section:monotonicity-proof}.
\end{proof}

\subsection{Generalized Independence}\label{subsection:quasi-generalized-independence}

Recall from Chapter~\ref{ch:lvars} that in order to prove determinism
for $\lambdaLVar$, we needed to establish a ``frame property'' that
captures the idea that independent effects commute with each other.
For $\lambdaLVar$, the Independence lemma
(Lemma~\ref{lem:lvars-independence}) established that property.  It
shows that, if a configuration $\config{S}{e}$ can step to
$\config{S'}{e'}$, then it is possible to ``frame on'' an additional
store $S''$ without interfering with the ability to take a step---that
is, $\config{\lubstore{S}{S''}}{e} \parstepsto
\config{\lubstore{S'}{S''}}{e'}$, subject to certain restrictions on
$S''$.

For $\lambdaLVish$, we need to establish a similar frame property.
However, since we have generalized from the least-upper-bound writes
of the @put@ operation in Chapter~\ref{ch:lvars} to the arbitrary
update operations discussed in
Section~\ref{subsection:quasi-update-operations}, we also need to
generalize our frame property.  In fact, the original
Lemma~\ref{lem:lvars-independence} does not hold for $\lambdaLVish$ in
general.  As an example, consider an LVar whose states form a lattice
$\bot < 0 < 1 < \top$.  Consider the transition
\[
\config{\store{\storebinding{l}{0}{\frozenfalse}}}{\putiexp{l}}
\parstepsto \config{\store{\storebinding{l}{1}{\frozenfalse}}}{\unit},
\]
where the update operation $u_i$ happens to increment its argument by
one.  Now suppose that we wish to ``frame'' the store
$\store{\storebinding{l}{1}{\frozenfalse}}$ onto this transition using
Lemma~\ref{lem:lvars-independence}; that is, we wish to show that
\[
\config{\lubstore{\store{\storebinding{l}{0}{\frozenfalse}}}{\store{\storebinding{l}{1}{\frozenfalse}}}}{\putiexp{l}}
\parstepsto
\config{\lubstore{\store{\storebinding{l}{1}{\frozenfalse}}}{\store{\storebinding{l}{1}{\frozenfalse}}}}{\unit}.
\]
We know that
$\lubstore{\store{\storebinding{l}{1}{\frozenfalse}}}{\store{\storebinding{l}{1}{\frozenfalse}}}
\neq \topS$, which is required to be able to apply
Lemma~\ref{lem:lvars-independence}.  Furthermore,
$\store{\storebinding{l}{1}{\frozenfalse}}$ is non-conflicting with
the original transition, since no new locations are allocated between
$\store{\storebinding{l}{0}{\frozenfalse}}$ and
$\store{\storebinding{l}{1}{\frozenfalse}}$.  However, it is
\emph{not} the case that
$\config{\lubstore{\store{\storebinding{l}{0}{\frozenfalse}}}{\store{\storebinding{l}{1}{\frozenfalse}}}}{\putiexp{l}}$
steps to
$\config{\lubstore{\store{\storebinding{l}{1}{\frozenfalse}}}{\store{\storebinding{l}{1}{\frozenfalse}}}}{\unit}$,
because $u_{p_i}((\lubstore{S}{S''})(l)) = \topp$.  (As before,
$u_{p_i}$ is the update operation $u_i$, lifted from lattice elements
$d$ to states $\state{d}{\status}$.)

What went wrong here?  The problem is that, as previously discussed in
Section~\ref{subsection:lvars-generalizing-from-least-upper-bound-writes},
lub operations do not necessarily commute with arbitrary update
operations.  In $\lambdaLVar$, where the only ``update operation'' is
a least-upper-bound write performed via @put@, it is fine that the
Independence lemma uses a lub operation to frame $S''$ onto the
transition. For $\lambdaLVish$, though, we need to state our frame
property in a way that will allow it to accommodate any update
operation from the given set $U$.

Therefore, I define a \emph{store update operation} $U_S$ to be a
function from stores to stores that can add new bindings and update
existing bindings using operations $u_i$ from the given set $U$ of
update operations (or, more specifically, their lifted versions
$u_{p_i}$).

\DefStoreUpdateOperation

Definition~\ref{def:store-update-operation} says that applying $U_S$
to $S$ updates the contents of each $l in \dom{S}$, using some
$u_{p_i} \in U_p$.  Since the identity function is always implicitly a
member of $U_p$, $U_S$ can act as the identity on the contents of
locations $l \in \dom{S}$.  $U_S$ can also add new bindings to the
store it operates on; however, it cannot change existing location
names.

With Definition~\ref{def:store-update-operation} in hand, we can state
a more general version of the Independence lemma:

\LemGeneralizedIndependence
\begin{proof}
  By cases on the rule of the reduction semantics by which
  $\config{S}{e}$ steps to $\config{S'}{e'}$.  The interesting cases
  are for the {\sc E-New}, {\sc E-Put}, {\sc E-Freeze-Final}, and {\sc
    E-Freeze-Simple} rules.  See
  Section~\ref{section:generalized-independence-proof}.
\end{proof}

Lemma~\ref{lem:generalized-independence} has three preconditions on
the store update operation $U_S$, two of which mirror the two
preconditions on $S''$ from the original Independence lemma: the
requirement that $U_S(S') \neq \topS$, and the requirement that $U_S$
is non-conflicting with the transition from $\config{S}{e}$ to
$\config{S'}{e'}$.
Definition~\ref{def:non-conflicting-store-update-operation} revises
our previous definition of non-conflicting to apply to store update
operations.  It says that $U_S$ is non-conflicting with the transition
$\config{S}{e} \parstepsto \config{S'}{e'}$ if, for all locations
allocated during the transition, $U_S$ does not interfere with those
locations.  For instance, if $l$ is allocated in the transition from
$\config{S}{e}$ to $\config{S'}{e'}$, then $l \notin \dom{U_S(S)}$
(that is, $U_S$ cannot add a binding at $l$ to $S$), and $(U_S(S'))(l)
= S'(l)$ (that is, $U_S$ cannot update the contents of $l$ in $S'$).

\DefNonConflictingStoreUpdateOperation

The third precondition on $U_S$ has to do with freezing: the stores
$U_S(S')$ and $S$ must be \emph{equal in status}, which means that,
for all the locations shared between them, the status bits of those
locations agree.  This precondition is only needed in the {\sc
  E-Freeze-Final} and {\sc E-Freeze-Simple} cases, and it has the
effect of ruling out interference from freezing.  Interestingly,
though, the precondition that $U_S(S')$ and $S$ be equal in status
does not rule out all applications of the {\sc E-Freeze-Final} and
{\sc E-Freeze-Simple} rules, because there \emph{are} @freeze@
operations with which update operations commute: those where the LVar
in question is already frozen!

\DefEqualStatus

The two changes we have made to the Independence lemma---the use of
$U_S$, and the requirement that the final store be equal in status to
$S$---are orthogonal to each other, in accordance with the fact that
\emph{arbitrary update operations} are an orthogonal language feature
to \emph{freezing}.  A version of $\lambdaLVish$ that had freezing,
but retained the least-upper-bound @put@ semantics of $\lambdaLVar$,
could use the old formulation of the Independence lemma, taking the
least upper bound of the original stores and a frame store $S''$, but
it would still need to require that $\lubstore{S'}{S''} \statuseq S$.
On the other hand, a version of the language \emph{without} freezing,
but \emph{with} arbitrary updates, would still use $U_S$ but could
leave out the requirement that $U_S(S')$ be equal in status to $S$.  I
make particular note of the orthogonality of freezing and arbitrary
updates because freezing introduces quasi-determinism, while arbitrary
updates do not.\footnote{To rigorously show that arbitrary updates
  retain full determinism and not merely quasi-determinism, I would
  need to define yet another language, one that generalizes \il{put}
  to $\PUTi$ but does not introduce freezing, and then prove
  determinism for \emph{that} language.  Instead, I hope to informally
  convince you that the quasi-determinism in $\lambdaLVish$ comes from
  freezing, rather than from arbitrary updates.}

Finally, although it no longer uses an explicit ``frame'' store, we
can still think of Lemma~\ref{lem:generalized-independence} as a frame
property; in fact, it is reminiscent of the generalized frame rule of
the ``Views'' framework~\cite{views}, which I discuss in more detail
in Section~\ref{s:related-frame-properties-and-separation-logics}.

\subsection{Quasi-Confluence}\label{subsection:quasi-quasi-confluence}

Lemma~\ref{lem:strong-local-quasi-confluence} says that if a
configuration $\conf$ can step to configurations $\conf_a$ and
$\conf_b$, then one of two possibilities is true: either there exists
a configuration $\conf_c$ that $\conf_a$ and $\conf_b$ can each reach
in at most one step, modulo a permutation on locations, \emph{or} at
least one of $\conf_a$ or $\conf_b$ steps to $\error$.
Lemmas~\ref{lem:strong-one-sided-quasi-confluence}
and~\ref{lem:strong-quasi-confluence} then generalize that result to
arbitrary numbers of steps.

\LemStrongLocalQuasiConfluence
\begin{proof}
  Similar to the proof of
  Lemma~\ref{lem:lvars-strong-local-confluence} (Strong Local
  Confluence for $\lambdaLVar$); see
  Section~\ref{section:strong-local-quasi-confluence-proof}.
  \TODO{Update description here once the proof is done.}
\end{proof}

\LemStrongOneSidedQuasiConfluence
\begin{proof}
  By induction on $m$; see
  Section~\ref{section:strong-one-sided-quasi-confluence-proof}.
\end{proof}

\LemStrongQuasiConfluence
\begin{proof}
  By induction on $n$; see
  Section~\ref{section:strong-quasi-confluence-proof}.
\end{proof}

\LemQuasiConfluence
 
\subsection{Quasi-determinism theorem}\label{subsection:quasi-quasi-determinism}

The Quasi-Determinism theorem, Theorem~\ref{thm:quasi-determinism}, is
a straightforward result of Lemma~\ref{lem:quasi-confluence}.  It says
that if two executions starting from a configuration $\conf$ terminate
in configurations $\conf'$ and $\conf''$, then $\conf'$ and $\conf''$
are the same configuration, or one of them is $\error$.

\ThmQuasiDeterminism
\begin{proof}
  By Lemma~\ref{lem:quasi-confluence}, one of the following two cases
  applies:
  \begin{enumerate}
    \item There exists $\conf_c$ and $\pi$ such that $\conf'
      \ctxstepsto^* \conf_c$ and $\pi(\conf'') \ctxstepsto^* \conf_c$.
      Since $\conf'$ cannot step, we must have $\conf' = \conf_c$.

      By Lemma~\ref{lem:permutability} (Permutability), $\conf''$ can
      step iff $\pi(\conf'')$ can step, so since $\conf''$ cannot
      step, $\pi(\conf'')$ cannot step either.

      Hence we must have $\pi(\conf'') = \conf_c$.  Since $\conf' =
      \conf_c$ and $\pi(\conf'') = \conf_c$, $\conf' = \pi(\conf'')$.
    \item $\conf' = \error$ or $\conf'' = \error$, and so the result
      is immediate.
  \end{enumerate}
\end{proof}

\subsection{Discussion: quasi-determinism in practice}

\lk{I kinda threw this subsection in here on a whim.  Maybe it should
  actually go somewhere in Chapter 4, or maybe it should be its own
  section.}

The quasi-determinism result for $\lambdaLVish$ shows that it is not
possible to get multiple ``answers'' from the same program: every run
will either produce the same answer or an error.  Importantly, this
property is true not only for programs that use the freeze-after
pattern expressed by the $\FAW$ primitive, but even those that freeze
in arbitrary places using the simpler @freeze@ primitive.  This means
that in practice, in a programming model based on LVars with freezing
and handlers, even a program that fails to ensure quiescence
(introducing the possibility of a race between a @put@ and a
@freeze@) cannot produce multiple non-$\error$ answers.

Therefore the LVish programming model is fundamentally different from
one in which the programmer must manually insert synchronization
barriers to prevent data races.  In that kind of a model, a program
with a misplaced synchronization barrier can be fully
nondeterministic, producing multiple observable answers.  In the LVish
model, the worst that can happen is that the program raises an error.
Moreover, in the LVish model, an $\error$ result \emph{always} means
that there is an undersynchronization bug in the program, and in
principle the error message can even specify exactly which write
operation happened after which freeze operation, making it easier to
debug the problem.

However, if we \emph{can} ensure that an LVar is only ever frozen
\emph{after} all writes to that LVar have completed, then we can
guarantee full determinism, because we will have ruled out races
between write operations and freeze operations.  In the next chapter,
I discuss how the LVish Haskell library enforces this ``freeze after
writing'' property.
